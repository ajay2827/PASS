import{c as pt,a as er}from"./index-3e1e2905.js";function tr(e,t){for(var n=0;n<t.length;n++){const r=t[n];if(typeof r!="string"&&!Array.isArray(r)){for(const i in r)if(i!=="default"&&!(i in e)){const a=Object.getOwnPropertyDescriptor(r,i);a&&Object.defineProperty(e,i,a.get?a:{enumerable:!0,get:()=>r[i]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}var He={},nr={get exports(){return He},set exports(e){He=e}},En={},Qt=class An{constructor(t,n=new Map,r=0){this.prefix=t,this._existing=n,this.counter=r}clone(){const{prefix:t,_existing:n,counter:r}=this;return new An(t,new Map(n),r)}getId(t){const n=t&&this._existing.get(t);if(n)return n;const r=this.prefix+this.counter;return this.counter++,t&&this._existing.set(t,r),r}hasId(t){return this._existing.has(t)}getOldIds(){return[...this._existing.keys()]}};(function(e,t){if(e.setImmediate)return;var n=1,r={},i=!1,a=e.document,s;function o(b){typeof b!="function"&&(b=new Function(""+b));for(var v=new Array(arguments.length-1),I=0;I<v.length;I++)v[I]=arguments[I+1];var w={callback:b,args:v};return r[n]=w,s(n),n++}function c(b){delete r[b]}function u(b){var v=b.callback,I=b.args;switch(I.length){case 0:v();break;case 1:v(I[0]);break;case 2:v(I[0],I[1]);break;case 3:v(I[0],I[1],I[2]);break;default:v.apply(t,I);break}}function d(b){if(i)setTimeout(d,0,b);else{var v=r[b];if(v){i=!0;try{u(v)}finally{c(b),i=!1}}}}function p(){s=function(b){process.nextTick(function(){d(b)})}}function y(){if(e.postMessage&&!e.importScripts){var b=!0,v=e.onmessage;return e.onmessage=function(){b=!1},e.postMessage("","*"),e.onmessage=v,b}}function l(){var b="setImmediate$"+Math.random()+"$",v=function(I){I.source===e&&typeof I.data=="string"&&I.data.indexOf(b)===0&&d(+I.data.slice(b.length))};e.addEventListener?e.addEventListener("message",v,!1):e.attachEvent("onmessage",v),s=function(I){e.postMessage(b+I,"*")}}function h(){var b=new MessageChannel;b.port1.onmessage=function(v){var I=v.data;d(I)},s=function(v){b.port2.postMessage(v)}}function f(){var b=a.documentElement;s=function(v){var I=a.createElement("script");I.onreadystatechange=function(){d(v),I.onreadystatechange=null,b.removeChild(I),I=null},b.appendChild(I)}}function g(){s=function(b){setTimeout(d,0,b)}}var m=Object.getPrototypeOf&&Object.getPrototypeOf(e);m=m&&m.setTimeout?m:e,{}.toString.call(e.process)==="[object process]"?p():y()?l():e.MessageChannel?h():a&&"onreadystatechange"in a.createElement("script")?f():g(),m.setImmediate=o,m.clearImmediate=c})(typeof self>"u"?typeof pt>"u"?pt:pt:self);/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */const gt=self.crypto||self.msCrypto;var dt=class{constructor(t){if(!(gt&&gt.subtle))throw new Error("crypto.subtle not found.");if(t==="sha256")this.algorithm={name:"SHA-256"};else if(t==="sha1")this.algorithm={name:"SHA-1"};else throw new Error(`Unsupported algorithm "${t}".`);this._content=""}update(t){this._content+=t}async digest(){const t=new TextEncoder().encode(this._content),n=new Uint8Array(await gt.subtle.digest(this.algorithm,t));let r="";for(let i=0;i<n.length;++i)r+=n[i].toString(16).padStart(2,"0");return r}};/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var Rn=class{constructor(t){this.current=t.sort(),this.done=!1,this.dir=new Map;for(let n=0;n<t.length;++n)this.dir.set(t[n],!0)}hasNext(){return!this.done}next(){const{current:t,dir:n}=this,r=t.slice();let i=null,a=0;const s=t.length;for(let o=0;o<s;++o){const c=t[o],u=n.get(c);(i===null||c>i)&&(u&&o>0&&c>t[o-1]||!u&&o<s-1&&c>t[o+1])&&(i=c,a=o)}if(i===null)this.done=!0;else{const o=n.get(i)?a-1:a+1;t[a]=t[o],t[o]=i;for(const c of t)c>i&&n.set(c,!n.get(c))}return r}};/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */const rr="http://www.w3.org/1999/02/22-rdf-syntax-ns#",yt=rr+"langString",mt="http://www.w3.org/2001/XMLSchema#string",Y="NamedNode",we="BlankNode",et="Literal",Ct="DefaultGraph",Re={};(()=>{const e="(?:<([^:]+:[^>]*)>)",n="A-Za-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�"+"_",r=n+"0-9-·̀-ͯ‿-⁀",a="(_:(?:["+n+"0-9])(?:(?:["+r+".])*(?:["+r+"]))?)",s='"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"',o="(?:\\^\\^"+e+")",c="(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))",u="(?:"+s+"(?:"+o+"|"+c+")?)",d="[ \\t]+",p="[ \\t]*",y="(?:"+e+"|"+a+")"+d,l=e+d,h="(?:"+e+"|"+a+"|"+u+")"+p,f="(?:\\.|(?:(?:"+e+"|"+a+")"+p+"\\.))";Re.eoln=/(?:\r\n)|(?:\n)|(?:\r)/g,Re.empty=new RegExp("^"+p+"$"),Re.quad=new RegExp("^"+p+y+l+h+f+p+"$")})();var Xt=class tt{static parse(t){const n=[],r={},i=t.split(Re.eoln);let a=0;for(const s of i){if(a++,Re.empty.test(s))continue;const o=s.match(Re.quad);if(o===null)throw new Error("N-Quads parse error on line "+a+".");const c={subject:null,predicate:null,object:null,graph:null};if(o[1]!==void 0?c.subject={termType:Y,value:o[1]}:c.subject={termType:we,value:o[2]},c.predicate={termType:Y,value:o[3]},o[4]!==void 0?c.object={termType:Y,value:o[4]}:o[5]!==void 0?c.object={termType:we,value:o[5]}:(c.object={termType:et,value:void 0,datatype:{termType:Y}},o[7]!==void 0?c.object.datatype.value=o[7]:o[8]!==void 0?(c.object.datatype.value=yt,c.object.language=o[8]):c.object.datatype.value=mt,c.object.value=lr(o[6])),o[9]!==void 0?c.graph={termType:Y,value:o[9]}:o[10]!==void 0?c.graph={termType:we,value:o[10]}:c.graph={termType:Ct,value:""},!(c.graph.value in r))r[c.graph.value]=[c],n.push(c);else{let u=!0;const d=r[c.graph.value];for(const p of d)if(sr(p,c)){u=!1;break}u&&(d.push(c),n.push(c))}}return n}static serialize(t){Array.isArray(t)||(t=tt.legacyDatasetToQuads(t));const n=[];for(const r of t)n.push(tt.serializeQuad(r));return n.sort().join("")}static serializeQuadComponents(t,n,r,i){let a="";return t.termType===Y?a+=`<${t.value}>`:a+=`${t.value}`,a+=` <${n.value}> `,r.termType===Y?a+=`<${r.value}>`:r.termType===we?a+=r.value:(a+=`"${ar(r.value)}"`,r.datatype.value===yt?r.language&&(a+=`@${r.language}`):r.datatype.value!==mt&&(a+=`^^<${r.datatype.value}>`)),i.termType===Y?a+=` <${i.value}>`:i.termType===we&&(a+=` ${i.value}`),a+=` .
`,a}static serializeQuad(t){return tt.serializeQuadComponents(t.subject,t.predicate,t.object,t.graph)}static legacyDatasetToQuads(t){const n=[],r={"blank node":we,IRI:Y,literal:et};for(const i in t)t[i].forEach(s=>{const o={};for(const c in s){const u=s[c],d={termType:r[u.type],value:u.value};d.termType===et&&(d.datatype={termType:Y},"datatype"in u&&(d.datatype.value=u.datatype),"language"in u?("datatype"in u||(d.datatype.value=yt),d.language=u.language):"datatype"in u||(d.datatype.value=mt)),o[c]=d}i==="@default"?o.graph={termType:Ct,value:""}:o.graph={termType:i.startsWith("_:")?we:Y,value:i},n.push(o)});return n}};function sr(e,t){return!(e.subject.termType===t.subject.termType&&e.object.termType===t.object.termType)||!(e.subject.value===t.subject.value&&e.predicate.value===t.predicate.value&&e.object.value===t.object.value)?!1:e.object.termType!==et?!0:e.object.datatype.termType===t.object.datatype.termType&&e.object.language===t.object.language&&e.object.datatype.value===t.object.datatype.value}const ir=/["\\\n\r]/g;function ar(e){return e.replace(ir,function(t){switch(t){case'"':return'\\"';case"\\":return"\\\\";case`
`:return"\\n";case"\r":return"\\r"}})}const or=/(?:\\([tbnrf"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g;function lr(e){return e.replace(or,function(t,n,r,i){if(n)switch(n){case"t":return"	";case"b":return"\b";case"n":return`
`;case"r":return"\r";case"f":return"\f";case'"':return'"';case"'":return"'";case"\\":return"\\"}if(r)return String.fromCharCode(parseInt(r,16));if(i)throw new Error("Unsupported U escape")})}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */const en=Qt,cr=dt,ur=Rn,tn=Xt;var Ln=class{constructor({createMessageDigest:t=()=>new cr("sha256"),maxDeepIterations:n=1/0}={}){this.name="URDNA2015",this.blankNodeInfo=new Map,this.canonicalIssuer=new en("_:c14n"),this.createMessageDigest=t,this.maxDeepIterations=n,this.quads=null,this.deepIterations=null}async main(t){this.deepIterations=new Map,this.quads=t;for(const c of t)this._addBlankNodeQuadInfo({quad:c,component:c.subject}),this._addBlankNodeQuadInfo({quad:c,component:c.object}),this._addBlankNodeQuadInfo({quad:c,component:c.graph});const n=new Map,r=[...this.blankNodeInfo.keys()];let i=0;for(const c of r)++i%100===0&&await this._yield(),await this._hashAndTrackBlankNode({id:c,hashToBlankNodes:n});const a=[...n.keys()].sort(),s=[];for(const c of a){const u=n.get(c);if(u.length>1){s.push(u);continue}const d=u[0];this.canonicalIssuer.getId(d)}for(const c of s){const u=[];for(const d of c){if(this.canonicalIssuer.hasId(d))continue;const p=new en("_:b");p.getId(d);const y=await this.hashNDegreeQuads(d,p);u.push(y)}u.sort(dr);for(const d of u){const p=d.issuer.getOldIds();for(const y of p)this.canonicalIssuer.getId(y)}}const o=[];for(const c of this.quads){const u=tn.serializeQuadComponents(this._componentWithCanonicalId(c.subject),c.predicate,this._componentWithCanonicalId(c.object),this._componentWithCanonicalId(c.graph));o.push(u)}return o.sort(),o.join("")}async hashFirstDegreeQuads(t){const n=[],r=this.blankNodeInfo.get(t),i=r.quads;for(const s of i){const o={subject:null,predicate:s.predicate,object:null,graph:null};o.subject=this.modifyFirstDegreeComponent(t,s.subject,"subject"),o.object=this.modifyFirstDegreeComponent(t,s.object,"object"),o.graph=this.modifyFirstDegreeComponent(t,s.graph,"graph"),n.push(tn.serializeQuad(o))}n.sort();const a=this.createMessageDigest();for(const s of n)a.update(s);return r.hash=await a.digest(),r.hash}async hashRelatedBlankNode(t,n,r,i){let a;this.canonicalIssuer.hasId(t)?a=this.canonicalIssuer.getId(t):r.hasId(t)?a=r.getId(t):a=this.blankNodeInfo.get(t).hash;const s=this.createMessageDigest();return s.update(i),i!=="g"&&s.update(this.getRelatedPredicate(n)),s.update(a),s.digest()}async hashNDegreeQuads(t,n){const r=this.deepIterations.get(t)||0;if(r>this.maxDeepIterations)throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);this.deepIterations.set(t,r+1);const i=this.createMessageDigest(),a=await this.createHashToRelated(t,n),s=[...a.keys()].sort();for(const o of s){i.update(o);let c="",u;const d=new ur(a.get(o));let p=0;for(;d.hasNext();){const y=d.next();++p%3===0&&await this._yield();let l=n.clone(),h="";const f=[];let g=!1;for(const m of y)if(this.canonicalIssuer.hasId(m)?h+=this.canonicalIssuer.getId(m):(l.hasId(m)||f.push(m),h+=l.getId(m)),c.length!==0&&h>c){g=!0;break}if(!g){for(const m of f){const b=await this.hashNDegreeQuads(m,l);if(h+=l.getId(m),h+=`<${b.hash}>`,l=b.issuer,c.length!==0&&h>c){g=!0;break}}g||(c.length===0||h<c)&&(c=h,u=l)}}i.update(c),n=u}return{hash:await i.digest(),issuer:n}}modifyFirstDegreeComponent(t,n){return n.termType!=="BlankNode"?n:{termType:"BlankNode",value:n.value===t?"_:a":"_:z"}}getRelatedPredicate(t){return`<${t.predicate.value}>`}async createHashToRelated(t,n){const r=new Map,i=this.blankNodeInfo.get(t).quads;let a=0;for(const s of i)++a%100===0&&await this._yield(),await Promise.all([this._addRelatedBlankNodeHash({quad:s,component:s.subject,position:"s",id:t,issuer:n,hashToRelated:r}),this._addRelatedBlankNodeHash({quad:s,component:s.object,position:"o",id:t,issuer:n,hashToRelated:r}),this._addRelatedBlankNodeHash({quad:s,component:s.graph,position:"g",id:t,issuer:n,hashToRelated:r})]);return r}async _hashAndTrackBlankNode({id:t,hashToBlankNodes:n}){const r=await this.hashFirstDegreeQuads(t),i=n.get(r);i?i.push(t):n.set(r,[t])}_addBlankNodeQuadInfo({quad:t,component:n}){if(n.termType!=="BlankNode")return;const r=n.value,i=this.blankNodeInfo.get(r);i?i.quads.add(t):this.blankNodeInfo.set(r,{quads:new Set([t]),hash:null})}async _addRelatedBlankNodeHash({quad:t,component:n,position:r,id:i,issuer:a,hashToRelated:s}){if(!(n.termType==="BlankNode"&&n.value!==i))return;const o=n.value,c=await this.hashRelatedBlankNode(o,t,a,r),u=s.get(c);u?u.push(o):s.set(c,[o])}_componentWithCanonicalId(t){return t.termType==="BlankNode"&&!t.value.startsWith(this.canonicalIssuer.prefix)?{termType:"BlankNode",value:this.canonicalIssuer.getId(t.value)}:t}async _yield(){return new Promise(t=>setImmediate(t))}};function dr(e,t){return e.hash<t.hash?-1:e.hash>t.hash?1:0}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */const fr=dt,hr=Ln;var pr=class extends hr{constructor(){super(),this.name="URGNA2012",this.createMessageDigest=()=>new fr("sha1")}modifyFirstDegreeComponent(t,n,r){return n.termType!=="BlankNode"?n:r==="graph"?{termType:"BlankNode",value:"_:g"}:{termType:"BlankNode",value:n.value===t?"_:a":"_:z"}}getRelatedPredicate(t){return t.predicate.value}async createHashToRelated(t,n){const r=new Map,i=this.blankNodeInfo.get(t).quads;let a=0;for(const s of i){let o,c;if(s.subject.termType==="BlankNode"&&s.subject.value!==t)c=s.subject.value,o="p";else if(s.object.termType==="BlankNode"&&s.object.value!==t)c=s.object.value,o="r";else continue;++a%100===0&&await this._yield();const u=await this.hashRelatedBlankNode(c,s,n,o),d=r.get(u);d?d.push(c):r.set(u,[c])}return r}};/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */const nn=Qt,gr=dt,yr=Rn,rn=Xt;var Tn=class{constructor({createMessageDigest:t=()=>new gr("sha256"),maxDeepIterations:n=1/0}={}){this.name="URDNA2015",this.blankNodeInfo=new Map,this.canonicalIssuer=new nn("_:c14n"),this.createMessageDigest=t,this.maxDeepIterations=n,this.quads=null,this.deepIterations=null}main(t){this.deepIterations=new Map,this.quads=t;for(const o of t)this._addBlankNodeQuadInfo({quad:o,component:o.subject}),this._addBlankNodeQuadInfo({quad:o,component:o.object}),this._addBlankNodeQuadInfo({quad:o,component:o.graph});const n=new Map,r=[...this.blankNodeInfo.keys()];for(const o of r)this._hashAndTrackBlankNode({id:o,hashToBlankNodes:n});const i=[...n.keys()].sort(),a=[];for(const o of i){const c=n.get(o);if(c.length>1){a.push(c);continue}const u=c[0];this.canonicalIssuer.getId(u)}for(const o of a){const c=[];for(const u of o){if(this.canonicalIssuer.hasId(u))continue;const d=new nn("_:b");d.getId(u);const p=this.hashNDegreeQuads(u,d);c.push(p)}c.sort(mr);for(const u of c){const d=u.issuer.getOldIds();for(const p of d)this.canonicalIssuer.getId(p)}}const s=[];for(const o of this.quads){const c=rn.serializeQuadComponents(this._componentWithCanonicalId({component:o.subject}),o.predicate,this._componentWithCanonicalId({component:o.object}),this._componentWithCanonicalId({component:o.graph}));s.push(c)}return s.sort(),s.join("")}hashFirstDegreeQuads(t){const n=[],r=this.blankNodeInfo.get(t),i=r.quads;for(const s of i){const o={subject:null,predicate:s.predicate,object:null,graph:null};o.subject=this.modifyFirstDegreeComponent(t,s.subject,"subject"),o.object=this.modifyFirstDegreeComponent(t,s.object,"object"),o.graph=this.modifyFirstDegreeComponent(t,s.graph,"graph"),n.push(rn.serializeQuad(o))}n.sort();const a=this.createMessageDigest();for(const s of n)a.update(s);return r.hash=a.digest(),r.hash}hashRelatedBlankNode(t,n,r,i){let a;this.canonicalIssuer.hasId(t)?a=this.canonicalIssuer.getId(t):r.hasId(t)?a=r.getId(t):a=this.blankNodeInfo.get(t).hash;const s=this.createMessageDigest();return s.update(i),i!=="g"&&s.update(this.getRelatedPredicate(n)),s.update(a),s.digest()}hashNDegreeQuads(t,n){const r=this.deepIterations.get(t)||0;if(r>this.maxDeepIterations)throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);this.deepIterations.set(t,r+1);const i=this.createMessageDigest(),a=this.createHashToRelated(t,n),s=[...a.keys()].sort();for(const o of s){i.update(o);let c="",u;const d=new yr(a.get(o));for(;d.hasNext();){const p=d.next();let y=n.clone(),l="";const h=[];let f=!1;for(const g of p)if(this.canonicalIssuer.hasId(g)?l+=this.canonicalIssuer.getId(g):(y.hasId(g)||h.push(g),l+=y.getId(g)),c.length!==0&&l>c){f=!0;break}if(!f){for(const g of h){const m=this.hashNDegreeQuads(g,y);if(l+=y.getId(g),l+=`<${m.hash}>`,y=m.issuer,c.length!==0&&l>c){f=!0;break}}f||(c.length===0||l<c)&&(c=l,u=y)}}i.update(c),n=u}return{hash:i.digest(),issuer:n}}modifyFirstDegreeComponent(t,n){return n.termType!=="BlankNode"?n:{termType:"BlankNode",value:n.value===t?"_:a":"_:z"}}getRelatedPredicate(t){return`<${t.predicate.value}>`}createHashToRelated(t,n){const r=new Map,i=this.blankNodeInfo.get(t).quads;for(const a of i)this._addRelatedBlankNodeHash({quad:a,component:a.subject,position:"s",id:t,issuer:n,hashToRelated:r}),this._addRelatedBlankNodeHash({quad:a,component:a.object,position:"o",id:t,issuer:n,hashToRelated:r}),this._addRelatedBlankNodeHash({quad:a,component:a.graph,position:"g",id:t,issuer:n,hashToRelated:r});return r}_hashAndTrackBlankNode({id:t,hashToBlankNodes:n}){const r=this.hashFirstDegreeQuads(t),i=n.get(r);i?i.push(t):n.set(r,[t])}_addBlankNodeQuadInfo({quad:t,component:n}){if(n.termType!=="BlankNode")return;const r=n.value,i=this.blankNodeInfo.get(r);i?i.quads.add(t):this.blankNodeInfo.set(r,{quads:new Set([t]),hash:null})}_addRelatedBlankNodeHash({quad:t,component:n,position:r,id:i,issuer:a,hashToRelated:s}){if(!(n.termType==="BlankNode"&&n.value!==i))return;const o=n.value,c=this.hashRelatedBlankNode(o,t,a,r),u=s.get(c);u?u.push(o):s.set(c,[o])}_componentWithCanonicalId({component:t}){return t.termType==="BlankNode"&&!t.value.startsWith(this.canonicalIssuer.prefix)?{termType:"BlankNode",value:this.canonicalIssuer.getId(t.value)}:t}};function mr(e,t){return e.hash<t.hash?-1:e.hash>t.hash?1:0}/*!
 * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.
 */const br=dt,vr=Tn;var wr=class extends vr{constructor(){super(),this.name="URGNA2012",this.createMessageDigest=()=>new br("sha1")}modifyFirstDegreeComponent(t,n,r){return n.termType!=="BlankNode"?n:r==="graph"?{termType:"BlankNode",value:"_:g"}:{termType:"BlankNode",value:n.value===t?"_:a":"_:z"}}getRelatedPredicate(t){return t.predicate.value}createHashToRelated(t,n){const r=new Map,i=this.blankNodeInfo.get(t).quads;for(const a of i){let s,o;if(a.subject.termType==="BlankNode"&&a.subject.value!==t)o=a.subject.value,s="p";else if(a.object.termType==="BlankNode"&&a.object.value!==t)o=a.object.value,s="r";else continue;const c=this.hashRelatedBlankNode(o,a,n,s),u=r.get(c);u?u.push(o):r.set(c,[o])}return r}};const Ir={},xr=Object.freeze(Object.defineProperty({__proto__:null,default:Ir},Symbol.toStringTag,{value:"Module"})),Nr=er(xr);(function(e){const t=Ln,n=pr,r=Tn,i=wr;let a;try{a=Nr}catch{}e.NQuads=Xt,e.IdentifierIssuer=Qt,e._rdfCanonizeNative=function(s){return s&&(a=s),a},e.canonize=async function(s,o){if(Array.isArray(s)||(s=e.NQuads.legacyDatasetToQuads(s)),o.useNative){if(!a)throw new Error("rdf-canonize-native not available");if(o.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "useNative".');return new Promise((c,u)=>a.canonize(s,o,(d,p)=>d?u(d):c(p)))}if(o.algorithm==="URDNA2015")return new t(o).main(s);if(o.algorithm==="URGNA2012"){if(o.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');return new n(o).main(s)}throw"algorithm"in o?new Error("Invalid RDF Dataset Canonicalization algorithm: "+o.algorithm):new Error("No RDF Dataset Canonicalization algorithm specified.")},e._canonizeSync=function(s,o){if(Array.isArray(s)||(s=e.NQuads.legacyDatasetToQuads(s)),o.useNative){if(!a)throw new Error("rdf-canonize-native not available");if(o.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "useNative".');return a.canonizeSync(s,o)}if(o.algorithm==="URDNA2015")return new r(o).main(s);if(o.algorithm==="URGNA2012"){if(o.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');return new i(o).main(s)}throw"algorithm"in o?new Error("Invalid RDF Dataset Canonicalization algorithm: "+o.algorithm):new Error("No RDF Dataset Canonicalization algorithm specified.")}})(En);(function(e){e.exports=En})(nr);const W={};var Z=W;W.isArray=Array.isArray;W.isBoolean=e=>typeof e=="boolean"||Object.prototype.toString.call(e)==="[object Boolean]";W.isDouble=e=>W.isNumber(e)&&(String(e).indexOf(".")!==-1||Math.abs(e)>=1e21);W.isEmptyObject=e=>W.isObject(e)&&Object.keys(e).length===0;W.isNumber=e=>typeof e=="number"||Object.prototype.toString.call(e)==="[object Number]";W.isNumeric=e=>!isNaN(parseFloat(e))&&isFinite(e);W.isObject=e=>Object.prototype.toString.call(e)==="[object Object]";W.isString=e=>typeof e=="string"||Object.prototype.toString.call(e)==="[object String]";W.isUndefined=e=>typeof e>"u";const ke=Z,de={};var fe=de;de.isSubject=e=>ke.isObject(e)&&!("@value"in e||"@set"in e||"@list"in e)?Object.keys(e).length>1||!("@id"in e):!1;de.isSubjectReference=e=>ke.isObject(e)&&Object.keys(e).length===1&&"@id"in e;de.isValue=e=>ke.isObject(e)&&"@value"in e;de.isList=e=>ke.isObject(e)&&"@list"in e;de.isGraph=e=>ke.isObject(e)&&"@graph"in e&&Object.keys(e).filter(t=>t!=="@id"&&t!=="@index").length===1;de.isSimpleGraph=e=>de.isGraph(e)&&!("@id"in e);de.isBlankNode=e=>ke.isObject(e)?"@id"in e?e["@id"].indexOf("_:")===0:Object.keys(e).length===0||!("@value"in e||"@set"in e||"@list"in e):!1;var ae=class extends Error{constructor(t="An unspecified JSON-LD error occurred.",n="jsonld.Error",r={}){super(t),this.name=n,this.message=t,this.details=r}};const Qe=fe,F=Z,kn=He.IdentifierIssuer,_r=ae,Sr=/(?:<[^>]*?>|"[^"]*?"|[^,])+/g,jr=/\s*<([^>]*?)>\s*(?:;\s*(.*))?/,Or=/(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g,sn={headers:{accept:"application/ld+json, application/json"}},O={};var ne=O;O.IdentifierIssuer=kn;O.clone=function(e){if(e&&typeof e=="object"){let t;if(F.isArray(e)){t=[];for(let n=0;n<e.length;++n)t[n]=O.clone(e[n])}else if(e instanceof Map){t=new Map;for(const[n,r]of e)t.set(n,O.clone(r))}else if(e instanceof Set){t=new Set;for(const n of e)t.add(O.clone(n))}else if(F.isObject(e)){t={};for(const n in e)t[n]=O.clone(e[n])}else t=e.toString();return t}return e};O.asArray=function(e){return Array.isArray(e)?e:[e]};O.buildHeaders=(e={})=>{if(Object.keys(e).some(n=>n.toLowerCase()==="accept"))throw new RangeError('Accept header may not be specified; only "'+sn.headers.accept+'" is supported.');return Object.assign({Accept:sn.headers.accept},e)};O.parseLinkHeader=e=>{const t={},n=e.match(Sr);for(let r=0;r<n.length;++r){let i=n[r].match(jr);if(!i)continue;const a={target:i[1]},s=i[2];for(;i=Or.exec(s);)a[i[1]]=i[2]===void 0?i[3]:i[2];const o=a.rel||"";Array.isArray(t[o])?t[o].push(a):t.hasOwnProperty(o)?t[o]=[t[o],a]:t[o]=a}return t};O.validateTypeValue=(e,t)=>{if(!F.isString(e)&&!(F.isArray(e)&&e.every(n=>F.isString(n)))){if(t&&F.isObject(e))switch(Object.keys(e).length){case 0:return;case 1:if("@default"in e&&O.asArray(e["@default"]).every(n=>F.isString(n)))return}throw new _r('Invalid JSON-LD syntax; "@type" value must a string, an array of strings, an empty object, or a default object.',"jsonld.SyntaxError",{code:"invalid type value",value:e})}};O.hasProperty=(e,t)=>{if(e.hasOwnProperty(t)){const n=e[t];return!F.isArray(n)||n.length>0}return!1};O.hasValue=(e,t,n)=>{if(O.hasProperty(e,t)){let r=e[t];const i=Qe.isList(r);if(F.isArray(r)||i){i&&(r=r["@list"]);for(let a=0;a<r.length;++a)if(O.compareValues(n,r[a]))return!0}else if(!F.isArray(n))return O.compareValues(n,r)}return!1};O.addValue=(e,t,n,r)=>{if(r=r||{},"propertyIsArray"in r||(r.propertyIsArray=!1),"valueIsArray"in r||(r.valueIsArray=!1),"allowDuplicate"in r||(r.allowDuplicate=!0),"prependValue"in r||(r.prependValue=!1),r.valueIsArray)e[t]=n;else if(F.isArray(n)){n.length===0&&r.propertyIsArray&&!e.hasOwnProperty(t)&&(e[t]=[]),r.prependValue&&(n=n.concat(e[t]),e[t]=[]);for(let i=0;i<n.length;++i)O.addValue(e,t,n[i],r)}else if(e.hasOwnProperty(t)){const i=!r.allowDuplicate&&O.hasValue(e,t,n);!F.isArray(e[t])&&(!i||r.propertyIsArray)&&(e[t]=[e[t]]),i||(r.prependValue?e[t].unshift(n):e[t].push(n))}else e[t]=r.propertyIsArray?[n]:n};O.getValues=(e,t)=>[].concat(e[t]||[]);O.removeProperty=(e,t)=>{delete e[t]};O.removeValue=(e,t,n,r)=>{r=r||{},"propertyIsArray"in r||(r.propertyIsArray=!1);const i=O.getValues(e,t).filter(a=>!O.compareValues(a,n));i.length===0?O.removeProperty(e,t):i.length===1&&!r.propertyIsArray?e[t]=i[0]:e[t]=i};O.relabelBlankNodes=(e,t)=>{t=t||{};const n=t.issuer||new kn("_:b");return nt(n,e)};O.compareValues=(e,t)=>e===t||Qe.isValue(e)&&Qe.isValue(t)&&e["@value"]===t["@value"]&&e["@type"]===t["@type"]&&e["@language"]===t["@language"]&&e["@index"]===t["@index"]?!0:F.isObject(e)&&"@id"in e&&F.isObject(t)&&"@id"in t?e["@id"]===t["@id"]:!1;O.compareShortestLeast=(e,t)=>e.length<t.length?-1:t.length<e.length?1:e===t?0:e<t?-1:1;function nt(e,t){if(F.isArray(t))for(let n=0;n<t.length;++n)t[n]=nt(e,t[n]);else if(Qe.isList(t))t["@list"]=nt(e,t["@list"]);else if(F.isObject(t)){Qe.isBlankNode(t)&&(t["@id"]=e.getId(t["@id"]));const n=Object.keys(t).sort();for(let r=0;r<n.length;++r){const i=n[r];i!=="@id"&&(t[i]=nt(e,t[i]))}}return t}const C="http://www.w3.org/1999/02/22-rdf-syntax-ns#",Me="http://www.w3.org/2001/XMLSchema#";var Kt={LINK_HEADER_REL:"http://www.w3.org/ns/json-ld#context",LINK_HEADER_CONTEXT:"http://www.w3.org/ns/json-ld#context",RDF:C,RDF_LIST:C+"List",RDF_FIRST:C+"first",RDF_REST:C+"rest",RDF_NIL:C+"nil",RDF_TYPE:C+"type",RDF_PLAIN_LITERAL:C+"PlainLiteral",RDF_XML_LITERAL:C+"XMLLiteral",RDF_JSON_LITERAL:C+"JSON",RDF_OBJECT:C+"object",RDF_LANGSTRING:C+"langString",XSD:Me,XSD_BOOLEAN:Me+"boolean",XSD_DOUBLE:Me+"double",XSD_INTEGER:Me+"integer",XSD_STRING:Me+"string"},bt,an;function Mn(){return an||(an=1,bt=class{constructor(){this._requests={}}wrapLoader(t){const n=this;return n._loader=t,function(){return n.add.apply(n,arguments)}}async add(t){let n=this._requests[t];if(n)return Promise.resolve(n);n=this._requests[t]=this._loader(t);try{return await n}finally{delete this._requests[t]}}}),bt}const ft=Z,J={};var ve=J;J.parsers={simple:{keys:["href","scheme","authority","path","query","fragment"],regex:/^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/},full:{keys:["href","protocol","scheme","authority","auth","user","password","hostname","port","path","directory","file","query","fragment"],regex:/^(([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/}};J.parse=(e,t)=>{const n={},r=J.parsers[t||"full"],i=r.regex.exec(e);let a=r.keys.length;for(;a--;)n[r.keys[a]]=i[a]===void 0?null:i[a];return(n.scheme==="https"&&n.port==="443"||n.scheme==="http"&&n.port==="80")&&(n.href=n.href.replace(":"+n.port,""),n.authority=n.authority.replace(":"+n.port,""),n.port=null),n.normalizedPath=J.removeDotSegments(n.path),n};J.prependBase=(e,t)=>{if(e===null||J.isAbsolute(t))return t;(!e||ft.isString(e))&&(e=J.parse(e||""));const n=J.parse(t),r={protocol:e.protocol||""};if(n.authority!==null)r.authority=n.authority,r.path=n.path,r.query=n.query;else if(r.authority=e.authority,n.path==="")r.path=e.path,n.query!==null?r.query=n.query:r.query=e.query;else{if(n.path.indexOf("/")===0)r.path=n.path;else{let a=e.path;a=a.substr(0,a.lastIndexOf("/")+1),(a.length>0||e.authority)&&a.substr(-1)!=="/"&&(a+="/"),a+=n.path,r.path=a}r.query=n.query}n.path!==""&&(r.path=J.removeDotSegments(r.path));let i=r.protocol;return r.authority!==null&&(i+="//"+r.authority),i+=r.path,r.query!==null&&(i+="?"+r.query),n.fragment!==null&&(i+="#"+n.fragment),i===""&&(i="./"),i};J.removeBase=(e,t)=>{if(e===null)return t;(!e||ft.isString(e))&&(e=J.parse(e||""));let n="";if(e.href!==""?n+=(e.protocol||"")+"//"+(e.authority||""):t.indexOf("//")&&(n+="//"),t.indexOf(n)!==0)return t;const r=J.parse(t.substr(n.length)),i=e.normalizedPath.split("/"),a=r.normalizedPath.split("/"),s=r.fragment||r.query?0:1;for(;i.length>0&&a.length>s&&i[0]===a[0];)i.shift(),a.shift();let o="";if(i.length>0){i.pop();for(let c=0;c<i.length;++c)o+="../"}return o+=a.join("/"),r.query!==null&&(o+="?"+r.query),r.fragment!==null&&(o+="#"+r.fragment),o===""&&(o="./"),o};J.removeDotSegments=e=>{if(e.length===0)return"";const t=e.split("/"),n=[];for(;t.length>0;){const r=t.shift(),i=t.length===0;if(r==="."){i&&n.push("");continue}if(r===".."){n.pop(),i&&n.push("");continue}n.push(r)}return e[0]==="/"&&n.length>0&&n[0]!==""&&n.unshift(""),n.length===1&&n[0]===""?"/":n.join("/")};const Dr=/^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;J.isAbsolute=e=>ft.isString(e)&&Dr.test(e);J.isRelative=e=>ft.isString(e);const{parseLinkHeader:Er,buildHeaders:Ar}=ne,{LINK_HEADER_CONTEXT:Rr}=Kt,$e=ae,Lr=Mn(),{prependBase:Tr}=ve,kr=/(^|(\r\n))link:/i;var Mr=({secure:e,headers:t={},xhr:n}={headers:{}})=>{return t=Ar(t),new Lr().wrapLoader(i);async function i(a){if(a.indexOf("http:")!==0&&a.indexOf("https:")!==0)throw new $e('URL could not be dereferenced; only "http" and "https" URLs are supported.',"jsonld.InvalidUrl",{code:"loading document failed",url:a});if(e&&a.indexOf("https")!==0)throw new $e(`URL could not be dereferenced; secure mode is enabled and the URL's scheme is not "https".`,"jsonld.InvalidUrl",{code:"loading document failed",url:a});let s;try{s=await $r(n,a,t)}catch(p){throw new $e("URL could not be dereferenced, an error occurred.","jsonld.LoadDocumentError",{code:"loading document failed",url:a,cause:p})}if(s.status>=400)throw new $e("URL could not be dereferenced: "+s.statusText,"jsonld.LoadDocumentError",{code:"loading document failed",url:a,httpStatusCode:s.status});let o={contextUrl:null,documentUrl:a,document:s.response},c=null;const u=s.getResponseHeader("Content-Type");let d;if(kr.test(s.getAllResponseHeaders())&&(d=s.getResponseHeader("Link")),d&&u!=="application/ld+json"){const p=Er(d),y=p[Rr];if(Array.isArray(y))throw new $e("URL could not be dereferenced, it has more than one associated HTTP Link Header.","jsonld.InvalidUrl",{code:"multiple context link headers",url:a});y&&(o.contextUrl=y.target),c=p.alternate,c&&c.type=="application/ld+json"&&!(u||"").match(/^application\/(\w*\+)?json$/)&&(o=await i(Tr(a,c.target)))}return o}};function $r(e,t,n){e=e||XMLHttpRequest;const r=new e;return new Promise((i,a)=>{r.onload=()=>i(r),r.onerror=s=>a(s),r.open("GET",t,!0);for(const s in n)r.setRequestHeader(s,n[s]);r.send()})}const Fr=Mr,Wt={};var Jr=Wt;Wt.setupDocumentLoaders=function(e){typeof XMLHttpRequest<"u"&&(e.documentLoaders.xhr=Fr,e.useDocumentLoader("xhr"))};Wt.setupGlobals=function(e){typeof globalThis.JsonLdProcessor>"u"&&Object.defineProperty(globalThis,"JsonLdProcessor",{writable:!0,enumerable:!1,configurable:!0,value:e.JsonLdProcessor})};var vt,on;function Br(){return on||(on=1,vt=function(e){e.prototype[Symbol.iterator]=function*(){for(let t=this.head;t;t=t.next)yield t.value}}),vt}var qr=j;j.Node=Se;j.create=j;function j(e){var t=this;if(t instanceof j||(t=new j),t.tail=null,t.head=null,t.length=0,e&&typeof e.forEach=="function")e.forEach(function(i){t.push(i)});else if(arguments.length>0)for(var n=0,r=arguments.length;n<r;n++)t.push(arguments[n]);return t}j.prototype.removeNode=function(e){if(e.list!==this)throw new Error("removing node which does not belong to this list");var t=e.next,n=e.prev;return t&&(t.prev=n),n&&(n.next=t),e===this.head&&(this.head=t),e===this.tail&&(this.tail=n),e.list.length--,e.next=null,e.prev=null,e.list=null,t};j.prototype.unshiftNode=function(e){if(e!==this.head){e.list&&e.list.removeNode(e);var t=this.head;e.list=this,e.next=t,t&&(t.prev=e),this.head=e,this.tail||(this.tail=e),this.length++}};j.prototype.pushNode=function(e){if(e!==this.tail){e.list&&e.list.removeNode(e);var t=this.tail;e.list=this,e.prev=t,t&&(t.next=e),this.tail=e,this.head||(this.head=e),this.length++}};j.prototype.push=function(){for(var e=0,t=arguments.length;e<t;e++)Ur(this,arguments[e]);return this.length};j.prototype.unshift=function(){for(var e=0,t=arguments.length;e<t;e++)Vr(this,arguments[e]);return this.length};j.prototype.pop=function(){if(this.tail){var e=this.tail.value;return this.tail=this.tail.prev,this.tail?this.tail.next=null:this.head=null,this.length--,e}};j.prototype.shift=function(){if(this.head){var e=this.head.value;return this.head=this.head.next,this.head?this.head.prev=null:this.tail=null,this.length--,e}};j.prototype.forEach=function(e,t){t=t||this;for(var n=this.head,r=0;n!==null;r++)e.call(t,n.value,r,this),n=n.next};j.prototype.forEachReverse=function(e,t){t=t||this;for(var n=this.tail,r=this.length-1;n!==null;r--)e.call(t,n.value,r,this),n=n.prev};j.prototype.get=function(e){for(var t=0,n=this.head;n!==null&&t<e;t++)n=n.next;if(t===e&&n!==null)return n.value};j.prototype.getReverse=function(e){for(var t=0,n=this.tail;n!==null&&t<e;t++)n=n.prev;if(t===e&&n!==null)return n.value};j.prototype.map=function(e,t){t=t||this;for(var n=new j,r=this.head;r!==null;)n.push(e.call(t,r.value,this)),r=r.next;return n};j.prototype.mapReverse=function(e,t){t=t||this;for(var n=new j,r=this.tail;r!==null;)n.push(e.call(t,r.value,this)),r=r.prev;return n};j.prototype.reduce=function(e,t){var n,r=this.head;if(arguments.length>1)n=t;else if(this.head)r=this.head.next,n=this.head.value;else throw new TypeError("Reduce of empty list with no initial value");for(var i=0;r!==null;i++)n=e(n,r.value,i),r=r.next;return n};j.prototype.reduceReverse=function(e,t){var n,r=this.tail;if(arguments.length>1)n=t;else if(this.tail)r=this.tail.prev,n=this.tail.value;else throw new TypeError("Reduce of empty list with no initial value");for(var i=this.length-1;r!==null;i--)n=e(n,r.value,i),r=r.prev;return n};j.prototype.toArray=function(){for(var e=new Array(this.length),t=0,n=this.head;n!==null;t++)e[t]=n.value,n=n.next;return e};j.prototype.toArrayReverse=function(){for(var e=new Array(this.length),t=0,n=this.tail;n!==null;t++)e[t]=n.value,n=n.prev;return e};j.prototype.slice=function(e,t){t=t||this.length,t<0&&(t+=this.length),e=e||0,e<0&&(e+=this.length);var n=new j;if(t<e||t<0)return n;e<0&&(e=0),t>this.length&&(t=this.length);for(var r=0,i=this.head;i!==null&&r<e;r++)i=i.next;for(;i!==null&&r<t;r++,i=i.next)n.push(i.value);return n};j.prototype.sliceReverse=function(e,t){t=t||this.length,t<0&&(t+=this.length),e=e||0,e<0&&(e+=this.length);var n=new j;if(t<e||t<0)return n;e<0&&(e=0),t>this.length&&(t=this.length);for(var r=this.length,i=this.tail;i!==null&&r>t;r--)i=i.prev;for(;i!==null&&r>e;r--,i=i.prev)n.push(i.value);return n};j.prototype.splice=function(e,t,...n){e>this.length&&(e=this.length-1),e<0&&(e=this.length+e);for(var r=0,i=this.head;i!==null&&r<e;r++)i=i.next;for(var a=[],r=0;i&&r<t;r++)a.push(i.value),i=this.removeNode(i);i===null&&(i=this.tail),i!==this.head&&i!==this.tail&&(i=i.prev);for(var r=0;r<n.length;r++)i=Pr(this,i,n[r]);return a};j.prototype.reverse=function(){for(var e=this.head,t=this.tail,n=e;n!==null;n=n.prev){var r=n.prev;n.prev=n.next,n.next=r}return this.head=t,this.tail=e,this};function Pr(e,t,n){var r=t===e.head?new Se(n,null,t,e):new Se(n,t,t.next,e);return r.next===null&&(e.tail=r),r.prev===null&&(e.head=r),e.length++,r}function Ur(e,t){e.tail=new Se(t,e.tail,null,e),e.head||(e.head=e.tail),e.length++}function Vr(e,t){e.head=new Se(t,null,e.head,e),e.tail||(e.tail=e.head),e.length++}function Se(e,t,n,r){if(!(this instanceof Se))return new Se(e,t,n,r);this.list=r,this.value=e,t?(t.next=this,this.prev=t):this.prev=null,n?(n.prev=this,this.next=n):this.next=null}try{Br()(j)}catch{}const Gr=qr,Ne=Symbol("max"),ce=Symbol("length"),De=Symbol("lengthCalculator"),Pe=Symbol("allowStale"),_e=Symbol("maxAge"),le=Symbol("dispose"),ln=Symbol("noDisposeOnSet"),k=Symbol("lruList"),te=Symbol("cache"),$n=Symbol("updateAgeOnGet"),wt=()=>1;class zr{constructor(t){if(typeof t=="number"&&(t={max:t}),t||(t={}),t.max&&(typeof t.max!="number"||t.max<0))throw new TypeError("max must be a non-negative number");this[Ne]=t.max||1/0;const n=t.length||wt;if(this[De]=typeof n!="function"?wt:n,this[Pe]=t.stale||!1,t.maxAge&&typeof t.maxAge!="number")throw new TypeError("maxAge must be a number");this[_e]=t.maxAge||0,this[le]=t.dispose,this[ln]=t.noDisposeOnSet||!1,this[$n]=t.updateAgeOnGet||!1,this.reset()}set max(t){if(typeof t!="number"||t<0)throw new TypeError("max must be a non-negative number");this[Ne]=t||1/0,Fe(this)}get max(){return this[Ne]}set allowStale(t){this[Pe]=!!t}get allowStale(){return this[Pe]}set maxAge(t){if(typeof t!="number")throw new TypeError("maxAge must be a non-negative number");this[_e]=t,Fe(this)}get maxAge(){return this[_e]}set lengthCalculator(t){typeof t!="function"&&(t=wt),t!==this[De]&&(this[De]=t,this[ce]=0,this[k].forEach(n=>{n.length=this[De](n.value,n.key),this[ce]+=n.length})),Fe(this)}get lengthCalculator(){return this[De]}get length(){return this[ce]}get itemCount(){return this[k].length}rforEach(t,n){n=n||this;for(let r=this[k].tail;r!==null;){const i=r.prev;cn(this,t,r,n),r=i}}forEach(t,n){n=n||this;for(let r=this[k].head;r!==null;){const i=r.next;cn(this,t,r,n),r=i}}keys(){return this[k].toArray().map(t=>t.key)}values(){return this[k].toArray().map(t=>t.value)}reset(){this[le]&&this[k]&&this[k].length&&this[k].forEach(t=>this[le](t.key,t.value)),this[te]=new Map,this[k]=new Gr,this[ce]=0}dump(){return this[k].map(t=>at(this,t)?!1:{k:t.key,v:t.value,e:t.now+(t.maxAge||0)}).toArray().filter(t=>t)}dumpLru(){return this[k]}set(t,n,r){if(r=r||this[_e],r&&typeof r!="number")throw new TypeError("maxAge must be a number");const i=r?Date.now():0,a=this[De](n,t);if(this[te].has(t)){if(a>this[Ne])return Le(this,this[te].get(t)),!1;const c=this[te].get(t).value;return this[le]&&(this[ln]||this[le](t,c.value)),c.now=i,c.maxAge=r,c.value=n,this[ce]+=a-c.length,c.length=a,this.get(t),Fe(this),!0}const s=new Hr(t,n,a,i,r);return s.length>this[Ne]?(this[le]&&this[le](t,n),!1):(this[ce]+=s.length,this[k].unshift(s),this[te].set(t,this[k].head),Fe(this),!0)}has(t){if(!this[te].has(t))return!1;const n=this[te].get(t).value;return!at(this,n)}get(t){return It(this,t,!0)}peek(t){return It(this,t,!1)}pop(){const t=this[k].tail;return t?(Le(this,t),t.value):null}del(t){Le(this,this[te].get(t))}load(t){this.reset();const n=Date.now();for(let r=t.length-1;r>=0;r--){const i=t[r],a=i.e||0;if(a===0)this.set(i.k,i.v);else{const s=a-n;s>0&&this.set(i.k,i.v,s)}}}prune(){this[te].forEach((t,n)=>It(this,n,!1))}}const It=(e,t,n)=>{const r=e[te].get(t);if(r){const i=r.value;if(at(e,i)){if(Le(e,r),!e[Pe])return}else n&&(e[$n]&&(r.value.now=Date.now()),e[k].unshiftNode(r));return i.value}},at=(e,t)=>{if(!t||!t.maxAge&&!e[_e])return!1;const n=Date.now()-t.now;return t.maxAge?n>t.maxAge:e[_e]&&n>e[_e]},Fe=e=>{if(e[ce]>e[Ne])for(let t=e[k].tail;e[ce]>e[Ne]&&t!==null;){const n=t.prev;Le(e,t),t=n}},Le=(e,t)=>{if(t){const n=t.value;e[le]&&e[le](n.key,n.value),e[ce]-=n.length,e[te].delete(n.key),e[k].removeNode(t)}};class Hr{constructor(t,n,r,i,a){this.key=t,this.value=n,this.length=r,this.now=i,this.maxAge=a||0}}const cn=(e,t,n,r)=>{let i=n.value;at(e,i)&&(Le(e,n),e[Pe]||(i=void 0)),i&&t.call(r,i.value,i.key,e)};var Fn=zr;const Qr=Fn,Xr=10;var Kr=class{constructor({document:t}){this.document=t,this.cache=new Qr({max:Xr})}getProcessed(t){return this.cache.get(t)}setProcessed(t,n){this.cache.set(t,n)}};const{isArray:$t,isObject:Ue,isString:ot}=Z,{asArray:Wr}=ne,{prependBase:Ft}=ve,Be=ae,un=Kr,dn=10;var Zr=class{constructor({sharedCache:t}){this.perOpCache=new Map,this.sharedCache=t}async resolve({activeCtx:t,context:n,documentLoader:r,base:i,cycles:a=new Set}){n&&Ue(n)&&n["@context"]&&(n=n["@context"]),n=Wr(n);const s=[];for(const o of n){if(ot(o)){let d=this._get(o);d||(d=await this._resolveRemoteContext({activeCtx:t,url:o,documentLoader:r,base:i,cycles:a})),$t(d)?s.push(...d):s.push(d);continue}if(o===null){s.push(new un({document:null}));continue}Ue(o)||Yr(n);const c=JSON.stringify(o);let u=this._get(c);u||(u=new un({document:o}),this._cacheResolvedContext({key:c,resolved:u,tag:"static"})),s.push(u)}return s}_get(t){let n=this.perOpCache.get(t);if(!n){const r=this.sharedCache.get(t);r&&(n=r.get("static"),n&&this.perOpCache.set(t,n))}return n}_cacheResolvedContext({key:t,resolved:n,tag:r}){if(this.perOpCache.set(t,n),r!==void 0){let i=this.sharedCache.get(t);i||(i=new Map,this.sharedCache.set(t,i)),i.set(r,n)}return n}async _resolveRemoteContext({activeCtx:t,url:n,documentLoader:r,base:i,cycles:a}){n=Ft(i,n);const{context:s,remoteDoc:o}=await this._fetchContext({activeCtx:t,url:n,documentLoader:r,cycles:a});i=o.documentUrl||n,Jt({context:s,base:i});const c=await this.resolve({activeCtx:t,context:s,documentLoader:r,base:i,cycles:a});return this._cacheResolvedContext({key:n,resolved:c,tag:o.tag}),c}async _fetchContext({activeCtx:t,url:n,documentLoader:r,cycles:i}){if(i.size>dn)throw new Be("Maximum number of @context URLs exceeded.","jsonld.ContextUrlError",{code:t.processingMode==="json-ld-1.0"?"loading remote context failed":"context overflow",max:dn});if(i.has(n))throw new Be("Cyclical @context URLs detected.","jsonld.ContextUrlError",{code:t.processingMode==="json-ld-1.0"?"recursive context inclusion":"context overflow",url:n});i.add(n);let a,s;try{s=await r(n),a=s.document||null,ot(a)&&(a=JSON.parse(a))}catch(o){throw new Be("Dereferencing a URL did not result in a valid JSON-LD object. Possible causes are an inaccessible URL perhaps due to a same-origin policy (ensure the server uses CORS if you are using client-side JavaScript), too many redirects, a non-JSON response, or more than one HTTP Link Header was provided for a remote context.","jsonld.InvalidUrl",{code:"loading remote context failed",url:n,cause:o})}if(!Ue(a))throw new Be("Dereferencing a URL did not result in a JSON object. The response was valid JSON, but it was not a JSON object.","jsonld.InvalidUrl",{code:"invalid remote context",url:n});return"@context"in a?a={"@context":a["@context"]}:a={"@context":{}},s.contextUrl&&($t(a["@context"])||(a["@context"]=[a["@context"]]),a["@context"].push(s.contextUrl)),{context:a,remoteDoc:s}}};function Yr(e){throw new Be("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:e})}function Jt({context:e,base:t}){if(!e)return;const n=e["@context"];if(ot(n)){e["@context"]=Ft(t,n);return}if($t(n)){for(let r=0;r<n.length;++r){const i=n[r];if(ot(i)){n[r]=Ft(t,i);continue}Ue(i)&&Jt({context:{"@context":i},base:t})}return}if(Ue(n))for(const r in n)Jt({context:n[r],base:t})}var Cr=He.NQuads;const lt=ne,_=ae,{isArray:Jn,isObject:ye,isString:U,isUndefined:es}=Z,{isAbsolute:Te,isRelative:ts,prependBase:Ve}=ve,{asArray:Bn,compareShortestLeast:ns}=ne,Ke=new Map,rs=1e4,rt=/^@[a-zA-Z]+$/,D={};var je=D;D.process=async({activeCtx:e,localCtx:t,options:n,propagate:r=!0,overrideProtected:i=!1,cycles:a=new Set})=>{if(ye(t)&&"@context"in t&&Jn(t["@context"])&&(t=t["@context"]),Bn(t).length===0)return e;const o=await n.contextResolver.resolve({activeCtx:e,context:t,documentLoader:n.documentLoader,base:n.base});ye(o[0].document)&&typeof o[0].document["@propagate"]=="boolean"&&(r=o[0].document["@propagate"]);let c=e;!r&&!c.previousContext&&(c=c.clone(),c.previousContext=e);for(const u of o){let{document:d}=u;if(e=c,d===null){if(!i&&Object.keys(e.protected).length!==0){const l=n&&n.protectedMode||"error";if(l==="error")throw new _("Tried to nullify a context with protected terms outside of a term definition.","jsonld.SyntaxError",{code:"invalid context nullification"});if(l==="warn"){console.warn("WARNING: invalid context nullification");const h=u.getProcessed(e);if(h){c=e=h;continue}const f=e;c=e=D.getInitialContext(n).clone();for(const[g,m]of Object.entries(f.protected))m&&(e.mappings[g]=lt.clone(f.mappings[g]));e.protected=lt.clone(f.protected),u.setProcessed(f,c);continue}throw new _("Invalid protectedMode.","jsonld.SyntaxError",{code:"invalid protected mode",context:t,protectedMode:l})}c=e=D.getInitialContext(n).clone();continue}const p=u.getProcessed(e);if(p){c=e=p;continue}if(ye(d)&&"@context"in d&&(d=d["@context"]),!ye(d))throw new _("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:d});c=c.clone();const y=new Map;if("@version"in d){if(d["@version"]!==1.1)throw new _("Unsupported JSON-LD version: "+d["@version"],"jsonld.UnsupportedVersion",{code:"invalid @version value",context:d});if(e.processingMode&&e.processingMode==="json-ld-1.0")throw new _("@version: "+d["@version"]+" not compatible with "+e.processingMode,"jsonld.ProcessingModeConflict",{code:"processing mode conflict",context:d});c.processingMode="json-ld-1.1",c["@version"]=d["@version"],y.set("@version",!0)}if(c.processingMode=c.processingMode||e.processingMode,"@base"in d){let l=d["@base"];if(!(l===null||Te(l)))if(ts(l))l=Ve(c["@base"],l);else throw new _('Invalid JSON-LD syntax; the value of "@base" in a @context must be an absolute IRI, a relative IRI, or null.',"jsonld.SyntaxError",{code:"invalid base IRI",context:d});c["@base"]=l,y.set("@base",!0)}if("@vocab"in d){const l=d["@vocab"];if(l===null)delete c["@vocab"];else if(U(l)){if(!Te(l)&&D.processingMode(c,1))throw new _('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be an absolute IRI.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:d});c["@vocab"]=Ae(c,l,{vocab:!0,base:!0},void 0,void 0,n)}else throw new _('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:d});y.set("@vocab",!0)}if("@language"in d){const l=d["@language"];if(l===null)delete c["@language"];else if(U(l))c["@language"]=l.toLowerCase();else throw new _('Invalid JSON-LD syntax; the value of "@language" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid default language",context:d});y.set("@language",!0)}if("@direction"in d){const l=d["@direction"];if(e.processingMode==="json-ld-1.0")throw new _("Invalid JSON-LD syntax; @direction not compatible with "+e.processingMode,"jsonld.SyntaxError",{code:"invalid context member",context:d});if(l===null)delete c["@direction"];else{if(l!=="ltr"&&l!=="rtl")throw new _('Invalid JSON-LD syntax; the value of "@direction" in a @context must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:d});c["@direction"]=l}y.set("@direction",!0)}if("@propagate"in d){const l=d["@propagate"];if(e.processingMode==="json-ld-1.0")throw new _("Invalid JSON-LD syntax; @propagate not compatible with "+e.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:d});if(typeof l!="boolean")throw new _("Invalid JSON-LD syntax; @propagate value must be a boolean.","jsonld.SyntaxError",{code:"invalid @propagate value",context:t});y.set("@propagate",!0)}if("@import"in d){const l=d["@import"];if(e.processingMode==="json-ld-1.0")throw new _("Invalid JSON-LD syntax; @import not compatible with "+e.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:d});if(!U(l))throw new _("Invalid JSON-LD syntax; @import must be a string.","jsonld.SyntaxError",{code:"invalid @import value",context:t});const h=await n.contextResolver.resolve({activeCtx:e,context:l,documentLoader:n.documentLoader,base:n.base});if(h.length!==1)throw new _("Invalid JSON-LD syntax; @import must reference a single context.","jsonld.SyntaxError",{code:"invalid remote context",context:t});const f=h[0].getProcessed(e);if(f)d=f;else{const g=h[0].document;if("@import"in g)throw new _("Invalid JSON-LD syntax: imported context must not include @import.","jsonld.SyntaxError",{code:"invalid context entry",context:t});for(const m in g)d.hasOwnProperty(m)||(d[m]=g[m]);h[0].setProcessed(e,d)}y.set("@import",!0)}y.set("@protected",d["@protected"]||!1);for(const l in d)if(D.createTermDefinition({activeCtx:c,localCtx:d,term:l,defined:y,options:n,overrideProtected:i}),ye(d[l])&&"@context"in d[l]){const h=d[l]["@context"];let f=!0;if(U(h)){const g=Ve(n.base,h);a.has(g)?f=!1:a.add(g)}if(f)try{await D.process({activeCtx:c.clone(),localCtx:d[l]["@context"],overrideProtected:!0,options:n,cycles:a})}catch{throw new _("Invalid JSON-LD syntax; invalid scoped context.","jsonld.SyntaxError",{code:"invalid scoped context",context:d[l]["@context"],term:l})}}u.setProcessed(e,c)}return c};D.createTermDefinition=({activeCtx:e,localCtx:t,term:n,defined:r,options:i,overrideProtected:a=!1})=>{if(r.has(n)){if(r.get(n))return;throw new _("Cyclical context definition detected.","jsonld.CyclicalContext",{code:"cyclic IRI mapping",context:t,term:n})}r.set(n,!1);let s;if(t.hasOwnProperty(n)&&(s=t[n]),n==="@type"&&ye(s)&&(s["@container"]||"@set")==="@set"&&D.processingMode(e,1.1)){const l=["@container","@id","@protected"],h=Object.keys(s);if(h.length===0||h.some(f=>!l.includes(f)))throw new _("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:t,term:n})}else{if(D.isKeyword(n))throw new _("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:t,term:n});if(n.match(rt)){console.warn('WARNING: terms beginning with "@" are reserved for future use and ignored',{term:n});return}else if(n==="")throw new _("Invalid JSON-LD syntax; a term cannot be an empty string.","jsonld.SyntaxError",{code:"invalid term definition",context:t})}const o=e.mappings.get(n);e.mappings.has(n)&&e.mappings.delete(n);let c=!1;if((U(s)||s===null)&&(c=!0,s={"@id":s}),!ye(s))throw new _("Invalid JSON-LD syntax; @context term values must be strings or objects.","jsonld.SyntaxError",{code:"invalid term definition",context:t});const u={};e.mappings.set(n,u),u.reverse=!1;const d=["@container","@id","@language","@reverse","@type"];D.processingMode(e,1.1)&&d.push("@context","@direction","@index","@nest","@prefix","@protected");for(const l in s)if(!d.includes(l))throw new _("Invalid JSON-LD syntax; a term definition must not contain "+l,"jsonld.SyntaxError",{code:"invalid term definition",context:t});const p=n.indexOf(":");if(u._termHasColon=p>0,"@reverse"in s){if("@id"in s)throw new _("Invalid JSON-LD syntax; a @reverse term definition must not contain @id.","jsonld.SyntaxError",{code:"invalid reverse property",context:t});if("@nest"in s)throw new _("Invalid JSON-LD syntax; a @reverse term definition must not contain @nest.","jsonld.SyntaxError",{code:"invalid reverse property",context:t});const l=s["@reverse"];if(!U(l))throw new _("Invalid JSON-LD syntax; a @context @reverse value must be a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:t});if(!D.isKeyword(l)&&l.match(rt)){console.warn('WARNING: values beginning with "@" are reserved for future use and ignored',{reverse:l}),o?e.mappings.set(n,o):e.mappings.delete(n);return}const h=Ae(e,l,{vocab:!0,base:!1},t,r,i);if(!Te(h))throw new _("Invalid JSON-LD syntax; a @context @reverse value must be an absolute IRI or a blank node identifier.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:t});u["@id"]=h,u.reverse=!0}else if("@id"in s){let l=s["@id"];if(l&&!U(l))throw new _("Invalid JSON-LD syntax; a @context @id value must be an array of strings or a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:t});if(l===null)u["@id"]=null;else if(!D.isKeyword(l)&&l.match(rt)){console.warn('WARNING: values beginning with "@" are reserved for future use and ignored',{id:l}),o?e.mappings.set(n,o):e.mappings.delete(n);return}else if(l!==n){if(l=Ae(e,l,{vocab:!0,base:!1},t,r,i),!Te(l)&&!D.isKeyword(l))throw new _("Invalid JSON-LD syntax; a @context @id value must be an absolute IRI, a blank node identifier, or a keyword.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:t});if(n.match(/(?::[^:])|\//)){const h=new Map(r).set(n,!0);if(Ae(e,n,{vocab:!0,base:!1},t,h,i)!==l)throw new _("Invalid JSON-LD syntax; term in form of IRI must expand to definition.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:t})}u["@id"]=l,u._prefix=c&&!u._termHasColon&&l.match(/[:\/\?#\[\]@]$/)}}if(!("@id"in u))if(u._termHasColon){const l=n.substr(0,p);if(t.hasOwnProperty(l)&&D.createTermDefinition({activeCtx:e,localCtx:t,term:l,defined:r,options:i}),e.mappings.has(l)){const h=n.substr(p+1);u["@id"]=e.mappings.get(l)["@id"]+h}else u["@id"]=n}else if(n==="@type")u["@id"]=n;else{if(!("@vocab"in e))throw new _("Invalid JSON-LD syntax; @context terms must define an @id.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:t,term:n});u["@id"]=e["@vocab"]+n}if((s["@protected"]===!0||r.get("@protected")===!0&&s["@protected"]!==!1)&&(e.protected[n]=!0,u.protected=!0),r.set(n,!0),"@type"in s){let l=s["@type"];if(!U(l))throw new _("Invalid JSON-LD syntax; an @context @type value must be a string.","jsonld.SyntaxError",{code:"invalid type mapping",context:t});if(l==="@json"||l==="@none"){if(D.processingMode(e,1))throw new _(`Invalid JSON-LD syntax; an @context @type value must not be "${l}" in JSON-LD 1.0 mode.`,"jsonld.SyntaxError",{code:"invalid type mapping",context:t})}else if(l!=="@id"&&l!=="@vocab"){if(l=Ae(e,l,{vocab:!0,base:!1},t,r,i),!Te(l))throw new _("Invalid JSON-LD syntax; an @context @type value must be an absolute IRI.","jsonld.SyntaxError",{code:"invalid type mapping",context:t});if(l.indexOf("_:")===0)throw new _("Invalid JSON-LD syntax; an @context @type value must be an IRI, not a blank node identifier.","jsonld.SyntaxError",{code:"invalid type mapping",context:t})}u["@type"]=l}if("@container"in s){const l=U(s["@container"])?[s["@container"]]:s["@container"]||[],h=["@list","@set","@index","@language"];let f=!0;const g=l.includes("@set");if(D.processingMode(e,1.1)){if(h.push("@graph","@id","@type"),l.includes("@list")){if(l.length!==1)throw new _("Invalid JSON-LD syntax; @context @container with @list must have no other values","jsonld.SyntaxError",{code:"invalid container mapping",context:t})}else if(l.includes("@graph")){if(l.some(m=>m!=="@graph"&&m!=="@id"&&m!=="@index"&&m!=="@set"))throw new _("Invalid JSON-LD syntax; @context @container with @graph must have no other values other than @id, @index, and @set","jsonld.SyntaxError",{code:"invalid container mapping",context:t})}else f&=l.length<=(g?2:1);if(l.includes("@type")&&(u["@type"]=u["@type"]||"@id",!["@id","@vocab"].includes(u["@type"])))throw new _("Invalid JSON-LD syntax; container: @type requires @type to be @id or @vocab.","jsonld.SyntaxError",{code:"invalid type mapping",context:t})}else f&=!Jn(s["@container"]),f&=l.length<=1;if(f&=l.every(m=>h.includes(m)),f&=!(g&&l.includes("@list")),!f)throw new _("Invalid JSON-LD syntax; @context @container value must be one of the following: "+h.join(", "),"jsonld.SyntaxError",{code:"invalid container mapping",context:t});if(u.reverse&&!l.every(m=>["@index","@set"].includes(m)))throw new _("Invalid JSON-LD syntax; @context @container value for a @reverse type definition must be @index or @set.","jsonld.SyntaxError",{code:"invalid reverse property",context:t});u["@container"]=l}if("@index"in s){if(!("@container"in s)||!u["@container"].includes("@index"))throw new _(`Invalid JSON-LD syntax; @index without @index in @container: "${s["@index"]}" on term "${n}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:t});if(!U(s["@index"])||s["@index"].indexOf("@")===0)throw new _(`Invalid JSON-LD syntax; @index must expand to an IRI: "${s["@index"]}" on term "${n}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:t});u["@index"]=s["@index"]}if("@context"in s&&(u["@context"]=s["@context"]),"@language"in s&&!("@type"in s)){let l=s["@language"];if(l!==null&&!U(l))throw new _("Invalid JSON-LD syntax; @context @language value must be a string or null.","jsonld.SyntaxError",{code:"invalid language mapping",context:t});l!==null&&(l=l.toLowerCase()),u["@language"]=l}if("@prefix"in s){if(n.match(/:|\//))throw new _("Invalid JSON-LD syntax; @context @prefix used on a compact IRI term","jsonld.SyntaxError",{code:"invalid term definition",context:t});if(D.isKeyword(u["@id"]))throw new _("Invalid JSON-LD syntax; keywords may not be used as prefixes","jsonld.SyntaxError",{code:"invalid term definition",context:t});if(typeof s["@prefix"]=="boolean")u._prefix=s["@prefix"]===!0;else throw new _("Invalid JSON-LD syntax; @context value for @prefix must be boolean","jsonld.SyntaxError",{code:"invalid @prefix value",context:t})}if("@direction"in s){const l=s["@direction"];if(l!==null&&l!=="ltr"&&l!=="rtl")throw new _('Invalid JSON-LD syntax; @direction value must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:t});u["@direction"]=l}if("@nest"in s){const l=s["@nest"];if(!U(l)||l!=="@nest"&&l.indexOf("@")===0)throw new _("Invalid JSON-LD syntax; @context @nest value must be a string which is not a keyword other than @nest.","jsonld.SyntaxError",{code:"invalid @nest value",context:t});u["@nest"]=l}// disallow aliasing @context and @preserve
const y=u["@id"];if(y==="@context"||y==="@preserve")throw new _("Invalid JSON-LD syntax; @context and @preserve cannot be aliased.","jsonld.SyntaxError",{code:"invalid keyword alias",context:t});if(o&&o.protected&&!a&&(e.protected[n]=!0,u.protected=!0,!Bt(o,u))){const l=i&&i.protectedMode||"error";if(l==="error")throw new _(`Invalid JSON-LD syntax; tried to redefine "${n}" which is a protected term.`,"jsonld.SyntaxError",{code:"protected term redefinition",context:t,term:n});if(l==="warn"){console.warn("WARNING: protected term redefinition",{term:n});return}throw new _("Invalid protectedMode.","jsonld.SyntaxError",{code:"invalid protected mode",context:t,term:n,protectedMode:l})}};D.expandIri=(e,t,n,r)=>Ae(e,t,n,void 0,void 0,r);function Ae(e,t,n,r,i,a){if(t===null||!U(t)||D.isKeyword(t))return t;if(t.match(rt))return null;if(r&&r.hasOwnProperty(t)&&i.get(t)!==!0&&D.createTermDefinition({activeCtx:e,localCtx:r,term:t,defined:i,options:a}),n=n||{},n.vocab){const o=e.mappings.get(t);if(o===null)return null;if(ye(o)&&"@id"in o)return o["@id"]}const s=t.indexOf(":");if(s>0){const o=t.substr(0,s),c=t.substr(s+1);if(o==="_"||c.indexOf("//")===0)return t;r&&r.hasOwnProperty(o)&&D.createTermDefinition({activeCtx:e,localCtx:r,term:o,defined:i,options:a});const u=e.mappings.get(o);if(u&&u._prefix)return u["@id"]+c;if(Te(t))return t}if(n.vocab&&"@vocab"in e)return e["@vocab"]+t;if(n.base&&"@base"in e){if(e["@base"])return Ve(Ve(a.base,e["@base"]),t)}else if(n.base)return Ve(a.base,t);return t}D.getInitialContext=e=>{const t=JSON.stringify({processingMode:e.processingMode}),n=Ke.get(t);if(n)return n;const r={processingMode:e.processingMode,mappings:new Map,inverse:null,getInverse:i,clone:o,revertToPreviousContext:c,protected:{}};return Ke.size===rs&&Ke.clear(),Ke.set(t,r),r;function i(){const u=this;if(u.inverse)return u.inverse;const d=u.inverse={},p=u.fastCurieMap={},y={},l=(u["@language"]||"@none").toLowerCase(),h=u["@direction"],f=u.mappings,g=[...f.keys()].sort(ns);for(const m of g){const b=f.get(m);if(b===null)continue;let v=b["@container"]||"@none";if(v=[].concat(v).sort().join(""),b["@id"]===null)continue;const I=Bn(b["@id"]);for(const w of I){let x=d[w];const N=D.isKeyword(w);if(x)!N&&!b._termHasColon&&y[w].push(m);else if(d[w]=x={},!N&&!b._termHasColon){y[w]=[m];const R={iri:w,terms:y[w]};w[0]in p?p[w[0]].push(R):p[w[0]]=[R]}if(x[v]||(x[v]={"@language":{},"@type":{},"@any":{}}),x=x[v],s(m,x["@any"],"@none"),b.reverse)s(m,x["@type"],"@reverse");else if(b["@type"]==="@none")s(m,x["@any"],"@none"),s(m,x["@language"],"@none"),s(m,x["@type"],"@none");else if("@type"in b)s(m,x["@type"],b["@type"]);else if("@language"in b&&"@direction"in b){const R=b["@language"],L=b["@direction"];R&&L?s(m,x["@language"],`${R}_${L}`.toLowerCase()):R?s(m,x["@language"],R.toLowerCase()):L?s(m,x["@language"],`_${L}`):s(m,x["@language"],"@null")}else"@language"in b?s(m,x["@language"],(b["@language"]||"@null").toLowerCase()):"@direction"in b?b["@direction"]?s(m,x["@language"],`_${b["@direction"]}`):s(m,x["@language"],"@none"):h?(s(m,x["@language"],`_${h}`),s(m,x["@language"],"@none"),s(m,x["@type"],"@none")):(s(m,x["@language"],l),s(m,x["@language"],"@none"),s(m,x["@type"],"@none"))}}for(const m in p)a(p,m,1);return d}function a(u,d,p){const y=u[d],l=u[d]={};let h,f;for(const g of y)h=g.iri,p>=h.length?f="":f=h[p],f in l?l[f].push(g):l[f]=[g];for(const g in l)g!==""&&a(l,g,p+1)}function s(u,d,p){d.hasOwnProperty(p)||(d[p]=u)}function o(){const u={};return u.mappings=lt.clone(this.mappings),u.clone=this.clone,u.inverse=null,u.getInverse=this.getInverse,u.protected=lt.clone(this.protected),this.previousContext&&(u.previousContext=this.previousContext.clone()),u.revertToPreviousContext=this.revertToPreviousContext,"@base"in this&&(u["@base"]=this["@base"]),"@language"in this&&(u["@language"]=this["@language"]),"@vocab"in this&&(u["@vocab"]=this["@vocab"]),u}function c(){return this.previousContext?this.previousContext.clone():this}};D.getContextValue=(e,t,n)=>{if(t===null)return n==="@context"?void 0:null;if(e.mappings.has(t)){const r=e.mappings.get(t);if(es(n))return r;if(r.hasOwnProperty(n))return r[n]}if(n==="@language"&&n in e||n==="@direction"&&n in e)return e[n];if(n!=="@context")return null};D.processingMode=(e,t)=>t.toString()>="1.1"?!e.processingMode||e.processingMode>="json-ld-"+t.toString():e.processingMode==="json-ld-1.0";D.isKeyword=e=>{if(!U(e)||e[0]!=="@")return!1;switch(e){case"@base":case"@container":case"@context":case"@default":case"@direction":case"@embed":case"@explicit":case"@graph":case"@id":case"@included":case"@index":case"@json":case"@language":case"@list":case"@nest":case"@none":case"@omitDefault":case"@prefix":case"@preserve":case"@protected":case"@requireAll":case"@reverse":case"@set":case"@type":case"@value":case"@version":case"@vocab":return!0}return!1};function Bt(e,t){if(!(e&&typeof e=="object")||!(t&&typeof t=="object"))return e===t;const n=Array.isArray(e);if(n!==Array.isArray(t))return!1;if(n){if(e.length!==t.length)return!1;for(let a=0;a<e.length;++a)if(!Bt(e[a],t[a]))return!1;return!0}const r=Object.keys(e),i=Object.keys(t);if(r.length!==i.length)return!1;for(const a in e){let s=e[a],o=t[a];if(a==="@container"&&Array.isArray(s)&&Array.isArray(o)&&(s=s.slice().sort(),o=o.slice().sort()),!Bt(s,o))return!1}return!0}const A=ae,{isArray:X,isObject:z,isEmptyObject:qt,isString:$,isUndefined:ct}=Z,{isList:xt,isValue:Pt,isGraph:ss,isSubject:is}=fe,{expandIri:T,getContextValue:K,isKeyword:Ut,process:Ge,processingMode:st}=je,{isAbsolute:qn}=ve,{addValue:G,asArray:ee,getValues:as,validateTypeValue:os}=ne,me={};var ls=me;const cs=/^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;me.expand=async({activeCtx:e,activeProperty:t=null,element:n,options:r={},insideList:i=!1,insideIndex:a=!1,typeScopedContext:s=null,expansionMap:o=()=>{}})=>{if(n==null)return null;if(t==="@default"&&(r=Object.assign({},r,{isFrame:!1})),!X(n)&&!z(n)){if(!i&&(t===null||T(e,t,{vocab:!0},r)==="@graph")){const f=await o({unmappedValue:n,activeCtx:e,activeProperty:t,options:r,insideList:i});return f===void 0?null:f}return Un({activeCtx:e,activeProperty:t,value:n,options:r})}if(X(n)){let f=[];const g=K(e,t,"@container")||[];i=i||g.includes("@list");for(let m=0;m<n.length;++m){let b=await me.expand({activeCtx:e,activeProperty:t,element:n[m],options:r,expansionMap:o,insideIndex:a,typeScopedContext:s});i&&X(b)&&(b={"@list":b}),!(b===null&&(b=await o({unmappedValue:n[m],activeCtx:e,activeProperty:t,parent:n,index:m,options:r,expandedParent:f,insideList:i}),b===void 0))&&(X(b)?f=f.concat(b):f.push(b))}return f}const c=T(e,t,{vocab:!0},r),u=K(e,t,"@context");s=s||(e.previousContext?e:null);let d=Object.keys(n).sort(),p=!a;if(p&&s&&d.length<=2&&!d.includes("@context"))for(const f of d){const g=T(s,f,{vocab:!0},r);if(g==="@value"){p=!1,e=s;break}if(g==="@id"&&d.length===1){p=!1;break}}p&&(e=e.revertToPreviousContext()),ct(u)||(e=await Ge({activeCtx:e,localCtx:u,propagate:!0,overrideProtected:!0,options:r})),"@context"in n&&(e=await Ge({activeCtx:e,localCtx:n["@context"],options:r})),s=e;let y=null;for(const f of d)if(T(e,f,{vocab:!0},r)==="@type"){y=y||f;const m=n[f],b=Array.isArray(m)?m.length>1?m.slice().sort():m:[m];for(const v of b){const I=K(s,v,"@context");ct(I)||(e=await Ge({activeCtx:e,localCtx:I,options:r,propagate:!1}))}}let l={};await Pn({activeCtx:e,activeProperty:t,expandedActiveProperty:c,element:n,expandedParent:l,options:r,insideList:i,typeKey:y,typeScopedContext:s,expansionMap:o}),d=Object.keys(l);let h=d.length;if("@value"in l){if("@type"in l&&("@language"in l||"@direction"in l))throw new A('Invalid JSON-LD syntax; an element containing "@value" may not contain both "@type" and either "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:l});let f=h-1;if("@type"in l&&(f-=1),"@index"in l&&(f-=1),"@language"in l&&(f-=1),"@direction"in l&&(f-=1),f!==0)throw new A('Invalid JSON-LD syntax; an element containing "@value" may only have an "@index" property and either "@type" or either or both "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:l});const g=l["@value"]===null?[]:ee(l["@value"]),m=as(l,"@type");if(!(st(e,1.1)&&m.includes("@json")&&m.length===1))if(g.length===0){const b=await o({unmappedValue:l,activeCtx:e,activeProperty:t,element:n,options:r,insideList:i});b!==void 0?l=b:l=null}else{if(!g.every(b=>$(b)||qt(b))&&"@language"in l)throw new A("Invalid JSON-LD syntax; only strings may be language-tagged.","jsonld.SyntaxError",{code:"invalid language-tagged value",element:l});if(!m.every(b=>qn(b)&&!($(b)&&b.indexOf("_:")===0)||qt(b)))throw new A('Invalid JSON-LD syntax; an element containing "@value" and "@type" must have an absolute IRI for the value of "@type".',"jsonld.SyntaxError",{code:"invalid typed value",element:l})}}else if("@type"in l&&!X(l["@type"]))l["@type"]=[l["@type"]];else if("@set"in l||"@list"in l){if(h>1&&!(h===2&&"@index"in l))throw new A('Invalid JSON-LD syntax; if an element has the property "@set" or "@list", then it can have at most one other property that is "@index".',"jsonld.SyntaxError",{code:"invalid set or list object",element:l});"@set"in l&&(l=l["@set"],d=Object.keys(l),h=d.length)}else if(h===1&&"@language"in l){const f=await o(l,{unmappedValue:l,activeCtx:e,activeProperty:t,element:n,options:r,insideList:i});f!==void 0?l=f:l=null}if(z(l)&&!r.keepFreeFloatingNodes&&!i&&(t===null||c==="@graph")&&(h===0||"@value"in l||"@list"in l||h===1&&"@id"in l)){const f=await o({unmappedValue:l,activeCtx:e,activeProperty:t,element:n,options:r,insideList:i});f!==void 0?l=f:l=null}return l};async function Pn({activeCtx:e,activeProperty:t,expandedActiveProperty:n,element:r,expandedParent:i,options:a={},insideList:s,typeKey:o,typeScopedContext:c,expansionMap:u}){const d=Object.keys(r).sort(),p=[];let y;const l=r[o]&&T(e,X(r[o])?r[o][0]:r[o],{vocab:!0},a)==="@json";for(const h of d){let f=r[h],g;if(h==="@context")continue;let m=T(e,h,{vocab:!0},a);if((m===null||!(qn(m)||Ut(m)))&&(m=u({unmappedProperty:h,activeCtx:e,activeProperty:t,parent:r,options:a,insideList:s,value:f,expandedParent:i}),m===void 0))continue;if(Ut(m)){if(n==="@reverse")throw new A("Invalid JSON-LD syntax; a keyword cannot be used as a @reverse property.","jsonld.SyntaxError",{code:"invalid reverse property map",value:f});if(m in i&&m!=="@included"&&m!=="@type")throw new A("Invalid JSON-LD syntax; colliding keywords detected.","jsonld.SyntaxError",{code:"colliding keywords",keyword:m})}if(m==="@id"){if(!$(f)){if(!a.isFrame)throw new A('Invalid JSON-LD syntax; "@id" value must a string.',"jsonld.SyntaxError",{code:"invalid @id value",value:f});if(z(f)){if(!qt(f))throw new A('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:f})}else if(X(f)){if(!f.every(w=>$(w)))throw new A('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:f})}else throw new A('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:f})}G(i,"@id",ee(f).map(w=>$(w)?T(e,w,{base:!0},a):w),{propertyIsArray:a.isFrame});continue}if(m==="@type"){z(f)&&(f=Object.fromEntries(Object.entries(f).map(([w,x])=>[T(c,w,{vocab:!0}),ee(x).map(N=>T(c,N,{base:!0,vocab:!0}))]))),os(f,a.isFrame),G(i,"@type",ee(f).map(w=>$(w)?T(c,w,{base:!0,vocab:!0},a):w),{propertyIsArray:a.isFrame});continue}if(m==="@included"&&st(e,1.1)){const w=ee(await me.expand({activeCtx:e,activeProperty:t,element:f,options:a,expansionMap:u}));if(!w.every(x=>is(x)))throw new A("Invalid JSON-LD syntax; values of @included must expand to node objects.","jsonld.SyntaxError",{code:"invalid @included value",value:f});G(i,"@included",w,{propertyIsArray:!0});continue}if(m==="@graph"&&!(z(f)||X(f)))throw new A('Invalid JSON-LD syntax; "@graph" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid @graph value",value:f});if(m==="@value"){y=f,l&&st(e,1.1)?i["@value"]=f:G(i,"@value",f,{propertyIsArray:a.isFrame});continue}if(m==="@language"){if(f===null)continue;if(!$(f)&&!a.isFrame)throw new A('Invalid JSON-LD syntax; "@language" value must be a string.',"jsonld.SyntaxError",{code:"invalid language-tagged string",value:f});f=ee(f).map(w=>$(w)?w.toLowerCase():w);for(const w of f)$(w)&&!w.match(cs)&&console.warn(`@language must be valid BCP47: ${w}`);G(i,"@language",f,{propertyIsArray:a.isFrame});continue}if(m==="@direction"){if(!$(f)&&!a.isFrame)throw new A('Invalid JSON-LD syntax; "@direction" value must be a string.',"jsonld.SyntaxError",{code:"invalid base direction",value:f});f=ee(f);for(const w of f)if($(w)&&w!=="ltr"&&w!=="rtl")throw new A('Invalid JSON-LD syntax; "@direction" must be "ltr" or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",value:f});G(i,"@direction",f,{propertyIsArray:a.isFrame});continue}if(m==="@index"){if(!$(f))throw new A('Invalid JSON-LD syntax; "@index" value must be a string.',"jsonld.SyntaxError",{code:"invalid @index value",value:f});G(i,"@index",f);continue}if(m==="@reverse"){if(!z(f))throw new A('Invalid JSON-LD syntax; "@reverse" value must be an object.',"jsonld.SyntaxError",{code:"invalid @reverse value",value:f});if(g=await me.expand({activeCtx:e,activeProperty:"@reverse",element:f,options:a,expansionMap:u}),"@reverse"in g)for(const x in g["@reverse"])G(i,x,g["@reverse"][x],{propertyIsArray:!0});let w=i["@reverse"]||null;for(const x in g){if(x==="@reverse")continue;w===null&&(w=i["@reverse"]={}),G(w,x,[],{propertyIsArray:!0});const N=g[x];for(let R=0;R<N.length;++R){const L=N[R];if(Pt(L)||xt(L))throw new A('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:g});G(w,x,L,{propertyIsArray:!0})}}continue}if(m==="@nest"){p.push(h);continue}let b=e;const v=K(e,h,"@context");ct(v)||(b=await Ge({activeCtx:e,localCtx:v,propagate:!0,overrideProtected:!0,options:a}));const I=K(b,h,"@container")||[];if(I.includes("@language")&&z(f)){const w=K(b,h,"@direction");g=us(b,f,w,a)}else if(I.includes("@index")&&z(f)){const w=I.includes("@graph"),x=K(b,h,"@index")||"@index",N=x!=="@index"&&T(e,x,{vocab:!0},a);g=await Nt({activeCtx:b,options:a,activeProperty:h,value:f,expansionMap:u,asGraph:w,indexKey:x,propertyIndex:N})}else if(I.includes("@id")&&z(f)){const w=I.includes("@graph");g=await Nt({activeCtx:b,options:a,activeProperty:h,value:f,expansionMap:u,asGraph:w,indexKey:"@id"})}else if(I.includes("@type")&&z(f))g=await Nt({activeCtx:b.revertToPreviousContext(),options:a,activeProperty:h,value:f,expansionMap:u,asGraph:!1,indexKey:"@type"});else{const w=m==="@list";if(w||m==="@set"){let x=t;w&&n==="@graph"&&(x=null),g=await me.expand({activeCtx:b,activeProperty:x,element:f,options:a,insideList:w,expansionMap:u})}else K(e,h,"@type")==="@json"?g={"@type":"@json","@value":f}:g=await me.expand({activeCtx:b,activeProperty:h,element:f,options:a,insideList:!1,expansionMap:u})}if(!(g===null&&m!=="@value"&&(g=u({unmappedValue:f,expandedProperty:m,activeCtx:b,activeProperty:t,parent:r,options:a,insideList:s,key:h,expandedParent:i}),g===void 0))){if(m!=="@list"&&!xt(g)&&I.includes("@list")&&(g={"@list":ee(g)}),I.includes("@graph")&&!I.some(w=>w==="@id"||w==="@index")&&(g=ee(g).map(w=>({"@graph":ee(w)}))),b.mappings.has(h)&&b.mappings.get(h).reverse){const w=i["@reverse"]=i["@reverse"]||{};g=ee(g);for(let x=0;x<g.length;++x){const N=g[x];if(Pt(N)||xt(N))throw new A('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:g});G(w,m,N,{propertyIsArray:!0})}continue}G(i,m,g,{propertyIsArray:!0})}}if("@value"in i&&!(i["@type"]==="@json"&&st(e,1.1))){if((z(y)||X(y))&&!a.isFrame)throw new A('Invalid JSON-LD syntax; "@value" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid value object value",value:y})}for(const h of p){const f=X(r[h])?r[h]:[r[h]];for(const g of f){if(!z(g)||Object.keys(g).some(m=>T(e,m,{vocab:!0},a)==="@value"))throw new A("Invalid JSON-LD syntax; nested value must be a node object.","jsonld.SyntaxError",{code:"invalid @nest value",value:g});await Pn({activeCtx:e,activeProperty:t,expandedActiveProperty:n,element:g,expandedParent:i,options:a,insideList:s,typeScopedContext:c,typeKey:o,expansionMap:u})}}}function Un({activeCtx:e,activeProperty:t,value:n,options:r}){if(n==null)return null;const i=T(e,t,{vocab:!0},r);if(i==="@id")return T(e,n,{base:!0},r);if(i==="@type")return T(e,n,{vocab:!0,base:!0},r);const a=K(e,t,"@type");if((a==="@id"||i==="@graph")&&$(n))return{"@id":T(e,n,{base:!0},r)};if(a==="@vocab"&&$(n))return{"@id":T(e,n,{vocab:!0,base:!0},r)};if(Ut(i))return n;const s={};if(a&&!["@id","@vocab","@none"].includes(a))s["@type"]=a;else if($(n)){const o=K(e,t,"@language");o!==null&&(s["@language"]=o);const c=K(e,t,"@direction");c!==null&&(s["@direction"]=c)}return["boolean","number","string"].includes(typeof n)||(n=n.toString()),s["@value"]=n,s}function us(e,t,n,r){const i=[],a=Object.keys(t).sort();for(const s of a){const o=T(e,s,{vocab:!0},r);let c=t[s];X(c)||(c=[c]);for(const u of c){if(u===null)continue;if(!$(u))throw new A("Invalid JSON-LD syntax; language map values must be strings.","jsonld.SyntaxError",{code:"invalid language map value",languageMap:t});const d={"@value":u};o!=="@none"&&(d["@language"]=s.toLowerCase()),n&&(d["@direction"]=n),i.push(d)}}return i}async function Nt({activeCtx:e,options:t,activeProperty:n,value:r,expansionMap:i,asGraph:a,indexKey:s,propertyIndex:o}){const c=[],u=Object.keys(r).sort(),d=s==="@type";for(let p of u){if(d){const h=K(e,p,"@context");ct(h)||(e=await Ge({activeCtx:e,localCtx:h,propagate:!1,options:t}))}let y=r[p];X(y)||(y=[y]),y=await me.expand({activeCtx:e,activeProperty:n,element:y,options:t,insideList:!1,insideIndex:!0,expansionMap:i});let l;o?p==="@none"?l="@none":l=Un({activeCtx:e,activeProperty:s,value:p,options:t}):l=T(e,p,{vocab:!0},t),s==="@id"?p=T(e,p,{base:!0},t):d&&(p=l);for(let h of y){if(a&&!ss(h)&&(h={"@graph":[h]}),s==="@type")l==="@none"||(h["@type"]?h["@type"]=[p].concat(h["@type"]):h["@type"]=[p]);else{if(Pt(h)&&!["@language","@type","@index"].includes(s))throw new A(`Invalid JSON-LD syntax; Attempt to add illegal key to value object: "${s}".`,"jsonld.SyntaxError",{code:"invalid value object",value:h});o?l!=="@none"&&G(h,o,l,{propertyIsArray:!0,prependValue:!0}):l!=="@none"&&!(s in h)&&(h[s]=p)}c.push(h)}}return c}const{isKeyword:Vn}=je,se=fe,_t=Z,ie=ne,ds=ae,q={};var ht=q;q.createMergedNodeMap=(e,t)=>{t=t||{};const n=t.issuer||new ie.IdentifierIssuer("_:b"),r={"@default":{}};return q.createNodeMap(e,r,"@default",n),q.mergeNodeMaps(r)};q.createNodeMap=(e,t,n,r,i,a)=>{if(_t.isArray(e)){for(const u of e)q.createNodeMap(u,t,n,r,void 0,a);return}if(!_t.isObject(e)){a&&a.push(e);return}if(se.isValue(e)){if("@type"in e){let u=e["@type"];u.indexOf("_:")===0&&(e["@type"]=u=r.getId(u))}a&&a.push(e);return}else if(a&&se.isList(e)){const u=[];q.createNodeMap(e["@list"],t,n,r,i,u),a.push({"@list":u});return}if("@type"in e){const u=e["@type"];for(const d of u)d.indexOf("_:")===0&&r.getId(d)}_t.isUndefined(i)&&(i=se.isBlankNode(e)?r.getId(e["@id"]):e["@id"]),a&&a.push({"@id":i});const s=t[n],o=s[i]=s[i]||{};o["@id"]=i;const c=Object.keys(e).sort();for(let u of c){if(u==="@id")continue;if(u==="@reverse"){const p={"@id":i},y=e["@reverse"];for(const l in y){const h=y[l];for(const f of h){let g=f["@id"];se.isBlankNode(f)&&(g=r.getId(g)),q.createNodeMap(f,t,n,r,g),ie.addValue(s[g],l,p,{propertyIsArray:!0,allowDuplicate:!1})}}continue}if(u==="@graph"){i in t||(t[i]={}),q.createNodeMap(e[u],t,i,r);continue}if(u==="@included"){q.createNodeMap(e[u],t,n,r);continue}if(u!=="@type"&&Vn(u)){if(u==="@index"&&u in o&&(e[u]!==o[u]||e[u]["@id"]!==o[u]["@id"]))throw new ds("Invalid JSON-LD syntax; conflicting @index property detected.","jsonld.SyntaxError",{code:"conflicting indexes",subject:o});o[u]=e[u];continue}const d=e[u];if(u.indexOf("_:")===0&&(u=r.getId(u)),d.length===0){ie.addValue(o,u,[],{propertyIsArray:!0});continue}for(let p of d)if(u==="@type"&&(p=p.indexOf("_:")===0?r.getId(p):p),se.isSubject(p)||se.isSubjectReference(p)){if("@id"in p&&!p["@id"])continue;const y=se.isBlankNode(p)?r.getId(p["@id"]):p["@id"];ie.addValue(o,u,{"@id":y},{propertyIsArray:!0,allowDuplicate:!1}),q.createNodeMap(p,t,n,r,y)}else if(se.isValue(p))ie.addValue(o,u,p,{propertyIsArray:!0,allowDuplicate:!1});else if(se.isList(p)){const y=[];q.createNodeMap(p["@list"],t,n,r,i,y),p={"@list":y},ie.addValue(o,u,p,{propertyIsArray:!0,allowDuplicate:!1})}else q.createNodeMap(p,t,n,r,i),ie.addValue(o,u,p,{propertyIsArray:!0,allowDuplicate:!1})}};q.mergeNodeMapGraphs=e=>{const t={};for(const n of Object.keys(e).sort())for(const r of Object.keys(e[n]).sort()){const i=e[n][r];r in t||(t[r]={"@id":r});const a=t[r];for(const s of Object.keys(i).sort())if(Vn(s)&&s!=="@type")a[s]=ie.clone(i[s]);else for(const o of i[s])ie.addValue(a,s,ie.clone(o),{propertyIsArray:!0,allowDuplicate:!1})}return t};q.mergeNodeMaps=e=>{const t=e["@default"],n=Object.keys(e).sort();for(const r of n){if(r==="@default")continue;const i=e[r];let a=t[r];a?"@graph"in a||(a["@graph"]=[]):t[r]=a={"@id":r,"@graph":[]};const s=a["@graph"];for(const o of Object.keys(i).sort()){const c=i[o];se.isSubjectReference(c)||s.push(c)}}return t};const{isSubjectReference:fs}=fe,{createMergedNodeMap:hs}=ht,Gn={};var ps=Gn;Gn.flatten=e=>{const t=hs(e),n=[],r=Object.keys(t).sort();for(let i=0;i<r.length;++i){const a=t[r[i]];fs(a)||n.push(a)}return n};const gs=ae,St=fe,qe=Z,fn=ne,{RDF_LIST:ys,RDF_FIRST:jt,RDF_REST:Ot,RDF_NIL:Dt,RDF_TYPE:ms,RDF_JSON_LITERAL:bs,XSD_BOOLEAN:hn,XSD_DOUBLE:pn,XSD_INTEGER:gn,XSD_STRING:Et}=Kt,vs=/^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/,zn={};var ws=zn;zn.fromRDF=async(e,{useRdfType:t=!1,useNativeTypes:n=!1,rdfDirection:r=null})=>{const i={},a={"@default":i},s={};for(const u of e){const d=u.graph.termType==="DefaultGraph"?"@default":u.graph.value;d in a||(a[d]={}),d!=="@default"&&!(d in i)&&(i[d]={"@id":d});const p=a[d],y=u.subject.value,l=u.predicate.value,h=u.object;y in p||(p[y]={"@id":y});const f=p[y],g=h.termType.endsWith("Node");if(g&&!(h.value in p)&&(p[h.value]={"@id":h.value}),l===ms&&!t&&g){fn.addValue(f,"@type",h.value,{propertyIsArray:!0});continue}const m=Is(h,n,r);if(fn.addValue(f,l,m,{propertyIsArray:!0}),g)if(h.value===Dt){const b=p[h.value];"usages"in b||(b.usages=[]),b.usages.push({node:f,property:l,value:m})}else h.value in s?s[h.value]=!1:s[h.value]={node:f,property:l,value:m}}for(const u in a){const d=a[u];if(!(Dt in d))continue;const p=d[Dt];if(p.usages){for(let y of p.usages){let l=y.node,h=y.property,f=y.value;const g=[],m=[];let b=Object.keys(l).length;for(;h===Ot&&qe.isObject(s[l["@id"]])&&qe.isArray(l[jt])&&l[jt].length===1&&qe.isArray(l[Ot])&&l[Ot].length===1&&(b===3||b===4&&qe.isArray(l["@type"])&&l["@type"].length===1&&l["@type"][0]===ys)&&(g.push(l[jt][0]),m.push(l["@id"]),y=s[l["@id"]],l=y.node,h=y.property,f=y.value,b=Object.keys(l).length,!!St.isBlankNode(l)););delete f["@id"],f["@list"]=g.reverse();for(const v of m)delete d[v]}delete p.usages}}const o=[],c=Object.keys(i).sort();for(const u of c){const d=i[u];if(u in a){const p=d["@graph"]=[],y=a[u],l=Object.keys(y).sort();for(const h of l){const f=y[h];St.isSubjectReference(f)||p.push(f)}}St.isSubjectReference(d)||o.push(d)}return o};function Is(e,t,n){if(e.termType.endsWith("Node"))return{"@id":e.value};const r={"@value":e.value};if(e.language)r["@language"]=e.language;else{let i=e.datatype.value;if(i||(i=Et),i===bs){i="@json";try{r["@value"]=JSON.parse(r["@value"])}catch(a){throw new gs("JSON literal could not be parsed.","jsonld.InvalidJsonLiteral",{code:"invalid JSON literal",value:r["@value"],cause:a})}}if(t){if(i===hn)r["@value"]==="true"?r["@value"]=!0:r["@value"]==="false"&&(r["@value"]=!1);else if(qe.isNumeric(r["@value"]))if(i===gn){const a=parseInt(r["@value"],10);a.toFixed(0)===r["@value"]&&(r["@value"]=a)}else i===pn&&(r["@value"]=parseFloat(r["@value"]));[hn,gn,pn,Et].includes(i)||(r["@type"]=i)}else if(n==="i18n-datatype"&&i.startsWith("https://www.w3.org/ns/i18n#")){const[,a,s]=i.split(/[#_]/);a.length>0&&(r["@language"]=a,a.match(vs)||console.warn(`@language must be valid BCP47: ${a}`)),r["@direction"]=s}else i!==Et&&(r["@type"]=i)}return r}var xs=function e(t){return t===null||typeof t!="object"||t.toJSON!=null?JSON.stringify(t):Array.isArray(t)?"["+t.reduce((n,r,i)=>{const a=i===0?"":",",s=r===void 0||typeof r=="symbol"?null:r;return n+a+e(s)},"")+"]":"{"+Object.keys(t).sort().reduce((n,r,i)=>{if(t[r]===void 0||typeof t[r]=="symbol")return n;const a=n.length===0?"":",";return n+a+e(r)+":"+e(t[r])},"")+"}"};const{createNodeMap:Ns}=ht,{isKeyword:_s}=je,yn=fe,Ss=xs,Je=Z,js=ne,{RDF_FIRST:Os,RDF_REST:Ds,RDF_NIL:Es,RDF_TYPE:As,RDF_JSON_LITERAL:Rs,RDF_LANGSTRING:Ls,XSD_BOOLEAN:Ts,XSD_DOUBLE:mn,XSD_INTEGER:ks,XSD_STRING:Ms}=Kt,{isAbsolute:ut}=ve,Hn={};var $s=Hn;Hn.toRDF=(e,t)=>{const n=new js.IdentifierIssuer("_:b"),r={"@default":{}};Ns(e,r,"@default",n);const i=[],a=Object.keys(r).sort();for(const s of a){let o;if(s==="@default")o={termType:"DefaultGraph",value:""};else if(ut(s))s.startsWith("_:")?o={termType:"BlankNode"}:o={termType:"NamedNode"},o.value=s;else continue;Fs(i,r[s],o,n,t)}return i};function Fs(e,t,n,r,i){const a=Object.keys(t).sort();for(const s of a){const o=t[s],c=Object.keys(o).sort();for(let u of c){const d=o[u];if(u==="@type")u=As;else if(_s(u))continue;for(const p of d){const y={termType:s.startsWith("_:")?"BlankNode":"NamedNode",value:s};if(!ut(s))continue;const l={termType:u.startsWith("_:")?"BlankNode":"NamedNode",value:u};if(!ut(u)||l.termType==="BlankNode"&&!i.produceGeneralizedRdf)continue;const h=Vt(p,r,e,n,i.rdfDirection);h&&e.push({subject:y,predicate:l,object:h,graph:n})}}}}function Js(e,t,n,r,i){const a={termType:"NamedNode",value:Os},s={termType:"NamedNode",value:Ds},o={termType:"NamedNode",value:Es},c=e.pop(),u=c?{termType:"BlankNode",value:t.getId()}:o;let d=u;for(const p of e){const y=Vt(p,t,n,r,i),l={termType:"BlankNode",value:t.getId()};n.push({subject:d,predicate:a,object:y,graph:r}),n.push({subject:d,predicate:s,object:l,graph:r}),d=l}if(c){const p=Vt(c,t,n,r,i);n.push({subject:d,predicate:a,object:p,graph:r}),n.push({subject:d,predicate:s,object:o,graph:r})}return u}function Vt(e,t,n,r,i){const a={};if(yn.isValue(e)){a.termType="Literal",a.value=void 0,a.datatype={termType:"NamedNode"};let s=e["@value"];const o=e["@type"]||null;if(o==="@json")a.value=Ss(s),a.datatype.value=Rs;else if(Je.isBoolean(s))a.value=s.toString(),a.datatype.value=o||Ts;else if(Je.isDouble(s)||o===mn)Je.isDouble(s)||(s=parseFloat(s)),a.value=s.toExponential(15).replace(/(\d)0*e\+?/,"$1E"),a.datatype.value=o||mn;else if(Je.isNumber(s))a.value=s.toFixed(0),a.datatype.value=o||ks;else if(i==="i18n-datatype"&&"@direction"in e){const c="https://www.w3.org/ns/i18n#"+(e["@language"]||"")+`_${e["@direction"]}`;a.datatype.value=c,a.value=s}else"@language"in e?(a.value=s,a.datatype.value=o||Ls,a.language=e["@language"]):(a.value=s,a.datatype.value=o||Ms)}else if(yn.isList(e)){const s=Js(e["@list"],t,n,r,i);a.termType=s.termType,a.value=s.value}else{const s=Je.isObject(e)?e["@id"]:e;a.termType=s.startsWith("_:")?"BlankNode":"NamedNode",a.value=s}return a.termType==="NamedNode"&&!ut(a.value)?null:a}const{isKeyword:Gt}=je,H=fe,E=Z,M=ne,bn=ve,ze=ae,{createNodeMap:Bs,mergeNodeMapGraphs:qs}=ht,Q={};var Ps=Q;Q.frameMergedOrDefault=(e,t,n)=>{const r={options:n,embedded:!1,graph:"@default",graphMap:{"@default":{}},subjectStack:[],link:{},bnodeMap:{}},i=new M.IdentifierIssuer("_:b");Bs(e,r.graphMap,"@default",i),n.merged&&(r.graphMap["@merged"]=qs(r.graphMap),r.graph="@merged"),r.subjects=r.graphMap[r.graph];const a=[];Q.frame(r,Object.keys(r.subjects).sort(),t,a),n.pruneBlankNodeIdentifiers&&(n.bnodesToClear=Object.keys(r.bnodeMap).filter(s=>r.bnodeMap[s].length===1));// remove @preserve from results
return n.link={},it(a,n)};Q.frame=(e,t,n,r,i=null)=>{Qn(n),n=n[0];const a=e.options,s={embed:We(n,a,"embed"),explicit:We(n,a,"explicit"),requireAll:We(n,a,"requireAll")};e.link.hasOwnProperty(e.graph)||(e.link[e.graph]={});const o=e.link[e.graph],c=Vs(e,t,n,s),u=Object.keys(c).sort();for(const d of u){const p=c[d];if(i===null?e.uniqueEmbeds={[e.graph]:{}}:e.uniqueEmbeds[e.graph]=e.uniqueEmbeds[e.graph]||{},s.embed==="@link"&&d in o){Ie(r,i,o[d]);continue}const y={"@id":d};if(d.indexOf("_:")===0&&M.addValue(e.bnodeMap,d,y,{propertyIsArray:!0}),o[d]=y,(s.embed==="@first"||s.embed==="@last")&&e.is11)throw new ze("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame:n});if(!(!e.embedded&&e.uniqueEmbeds[e.graph].hasOwnProperty(d))){if(e.embedded&&(s.embed==="@never"||Us(p,e.graph,e.subjectStack))){Ie(r,i,y);continue}if(e.embedded&&(s.embed=="@first"||s.embed=="@once")&&e.uniqueEmbeds[e.graph].hasOwnProperty(d)){Ie(r,i,y);continue}if(s.embed==="@last"&&d in e.uniqueEmbeds[e.graph]&&Gs(e,d),e.uniqueEmbeds[e.graph][d]={parent:r,property:i},e.subjectStack.push({subject:p,graph:e.graph}),d in e.graphMap){let l=!1,h=null;"@graph"in n?(h=n["@graph"][0],l=!(d==="@merged"||d==="@default"),E.isObject(h)||(h={})):(l=e.graph!=="@merged",h={}),l&&Q.frame({...e,graph:d,embedded:!1},Object.keys(e.graphMap[d]).sort(),[h],y,"@graph")}"@included"in n&&Q.frame({...e,embedded:!1},t,n["@included"],y,"@included");for(const l of Object.keys(p).sort()){if(Gt(l)){if(y[l]=M.clone(p[l]),l==="@type")for(const h of p["@type"])h.indexOf("_:")===0&&M.addValue(e.bnodeMap,h,y,{propertyIsArray:!0});continue}if(!(s.explicit&&!(l in n)))for(const h of p[l]){const f=l in n?n[l]:vn(s);if(H.isList(h)){const g=n[l]&&n[l][0]&&n[l][0]["@list"]?n[l][0]["@list"]:vn(s),m={"@list":[]};Ie(y,l,m);const b=h["@list"];for(const v of b)H.isSubjectReference(v)?Q.frame({...e,embedded:!0},[v["@id"]],g,m,"@list"):Ie(m,"@list",M.clone(v))}else H.isSubjectReference(h)?Q.frame({...e,embedded:!0},[h["@id"]],f,y,l):zt(f[0],h)&&Ie(y,l,M.clone(h))}}for(const l of Object.keys(n).sort()){if(l==="@type"){if(!E.isObject(n[l][0])||!("@default"in n[l][0]))continue}else if(Gt(l))continue;const h=n[l][0]||{};if(!We(h,a,"omitDefault")&&!(l in y)){let g="@null";"@default"in h&&(g=M.clone(h["@default"])),E.isArray(g)||(g=[g]),y[l]=[{"@preserve":g}]}}for(const l of Object.keys(n["@reverse"]||{}).sort()){const h=n["@reverse"][l];for(const f of Object.keys(e.subjects))M.getValues(e.subjects[f],l).some(m=>m["@id"]===d)&&(y["@reverse"]=y["@reverse"]||{},M.addValue(y["@reverse"],l,[],{propertyIsArray:!0}),Q.frame({...e,embedded:!0},[f],h,y["@reverse"][l],i))}Ie(r,i,y),e.subjectStack.pop()}}};Q.cleanupNull=(e,t)=>{if(E.isArray(e))return e.map(r=>Q.cleanupNull(r,t)).filter(r=>r);if(e==="@null")return null;if(E.isObject(e)){if("@id"in e){const n=e["@id"];if(t.link.hasOwnProperty(n)){const r=t.link[n].indexOf(e);if(r!==-1)return t.link[n][r];t.link[n].push(e)}else t.link[n]=[e]}for(const n in e)e[n]=Q.cleanupNull(e[n],t)}return e};function vn(e){const t={};for(const n in e)e[n]!==void 0&&(t["@"+n]=[e[n]]);return[t]}function Us(e,t,n){for(let r=n.length-1;r>=0;--r){const i=n[r];if(i.graph===t&&i.subject["@id"]===e["@id"])return!0}return!1}function We(e,t,n){const r="@"+n;let i=r in e?e[r][0]:t[n];if(n==="embed"){if(i===!0)i="@once";else if(i===!1)i="@never";else if(i!=="@always"&&i!=="@never"&&i!=="@link"&&i!=="@first"&&i!=="@last"&&i!=="@once")throw new ze("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame:e})}return i}function Qn(e){if(!E.isArray(e)||e.length!==1||!E.isObject(e[0]))throw new ze("Invalid JSON-LD syntax; a JSON-LD frame must be a single object.","jsonld.SyntaxError",{frame:e});if("@id"in e[0]){for(const t of M.asArray(e[0]["@id"]))if(!(E.isObject(t)||bn.isAbsolute(t))||E.isString(t)&&t.indexOf("_:")===0)throw new ze("Invalid JSON-LD syntax; invalid @id in frame.","jsonld.SyntaxError",{code:"invalid frame",frame:e})}if("@type"in e[0]){for(const t of M.asArray(e[0]["@type"]))if(!(E.isObject(t)||bn.isAbsolute(t))||E.isString(t)&&t.indexOf("_:")===0)throw new ze("Invalid JSON-LD syntax; invalid @type in frame.","jsonld.SyntaxError",{code:"invalid frame",frame:e})}}function Vs(e,t,n,r){const i={};for(const a of t){const s=e.graphMap[e.graph][a];Xn(e,s,n,r)&&(i[a]=s)}return i}function Xn(e,t,n,r){let i=!0,a=!1;for(const s in n){let o=!1;const c=M.getValues(t,s),u=M.getValues(n,s).length===0;if(s==="@id"){if(E.isEmptyObject(n["@id"][0]||{})?o=!0:n["@id"].length>=0&&(o=n["@id"].includes(c[0])),!r.requireAll)return o}else if(s==="@type"){if(i=!1,u){if(c.length>0)return!1;o=!0}else if(n["@type"].length===1&&E.isEmptyObject(n["@type"][0]))o=c.length>0;else for(const d of n["@type"])E.isObject(d)&&"@default"in d?o=!0:o=o||c.some(p=>p===d);if(!r.requireAll)return o}else{if(Gt(s))continue;{const d=M.getValues(n,s)[0];let p=!1;if(d&&(Qn([d]),p="@default"in d),i=!1,c.length===0&&p)continue;if(c.length>0&&u)return!1;if(d===void 0){if(c.length>0)return!1;o=!0}else if(H.isList(d)){const y=d["@list"][0];if(H.isList(c[0])){const l=c[0]["@list"];H.isValue(y)?o=l.some(h=>zt(y,h)):(H.isSubject(y)||H.isSubjectReference(y))&&(o=l.some(h=>wn(e,y,h,r)))}}else H.isValue(d)?o=c.some(y=>zt(d,y)):H.isSubjectReference(d)?o=c.some(y=>wn(e,d,y,r)):E.isObject(d)?o=c.length>0:o=!1}}if(!o&&r.requireAll)return!1;a=a||o}return i||a}function Gs(e,t){const n=e.uniqueEmbeds[e.graph],r=n[t],i=r.parent,a=r.property,s={"@id":t};if(E.isArray(i)){for(let c=0;c<i.length;++c)if(M.compareValues(i[c],s)){i[c]=s;break}}else{const c=E.isArray(i[a]);M.removeValue(i,a,s,{propertyIsArray:c}),M.addValue(i,a,s,{propertyIsArray:c})}const o=c=>{const u=Object.keys(n);for(const d of u)d in n&&E.isObject(n[d].parent)&&n[d].parent["@id"]===c&&(delete n[d],o(d))};o(t)}/**
 * Removes the @preserve keywords from expanded result of framing.
 *
 * @param input the framed, framed output.
 * @param options the framing options used.
 *
 * @return the resulting output.
 */function it(e,t){if(E.isArray(e))return e.map(n=>it(n,t));if(E.isObject(e)){// remove @preserve
if("@preserve"in e)return e["@preserve"][0];if(H.isValue(e))return e;if(H.isList(e))return e["@list"]=it(e["@list"],t),e;if("@id"in e){const n=e["@id"];if(t.link.hasOwnProperty(n)){const r=t.link[n].indexOf(e);if(r!==-1)return t.link[n][r];t.link[n].push(e)}else t.link[n]=[e]}for(const n in e){if(n==="@id"&&t.bnodesToClear.includes(e[n])){delete e["@id"];continue}e[n]=it(e[n],t)}}return e}function Ie(e,t,n){E.isObject(e)?M.addValue(e,t,n,{propertyIsArray:!0}):e.push(n)}function wn(e,t,n,r){if(!("@id"in n))return!1;const i=e.subjects[n["@id"]];return i&&Xn(e,i,t,r)}function zt(e,t){const n=t["@value"],r=t["@type"],i=t["@language"],a=e["@value"]?E.isArray(e["@value"])?e["@value"]:[e["@value"]]:[],s=e["@type"]?E.isArray(e["@type"])?e["@type"]:[e["@type"]]:[],o=e["@language"]?E.isArray(e["@language"])?e["@language"]:[e["@language"]]:[];return a.length===0&&s.length===0&&o.length===0?!0:!(!(a.includes(n)||E.isEmptyObject(a[0]))||!(!r&&s.length===0||s.includes(r)||r&&E.isEmptyObject(s[0]))||!(!i&&o.length===0||o.includes(i)||i&&E.isEmptyObject(o[0])))}const Zt=ae,{isArray:he,isObject:be,isString:Kn,isUndefined:At}=Z,{isList:Ht,isValue:ue,isGraph:Wn,isSimpleGraph:In,isSubjectReference:Rt}=fe,{expandIri:Zn,getContextValue:B,isKeyword:Yn,process:Lt,processingMode:zs}=je,{removeBase:xn,prependBase:Hs}=ve,{addValue:V,asArray:Ze,compareShortestLeast:Qs}=ne,S={};var Xs=S;S.compact=async({activeCtx:e,activeProperty:t=null,element:n,options:r={},compactionMap:i=()=>{}})=>{if(he(n)){let s=[];for(let o=0;o<n.length;++o){let c=await S.compact({activeCtx:e,activeProperty:t,element:n[o],options:r,compactionMap:i});c===null&&(c=await i({unmappedValue:n[o],activeCtx:e,activeProperty:t,parent:n,index:o,options:r}),c===void 0)||s.push(c)}return r.compactArrays&&s.length===1&&(B(e,t,"@container")||[]).length===0&&(s=s[0]),s}const a=B(e,t,"@context");if(At(a)||(e=await Lt({activeCtx:e,localCtx:a,propagate:!0,overrideProtected:!0,options:r})),be(n)){if(r.link&&"@id"in n&&r.link.hasOwnProperty(n["@id"])){const l=r.link[n["@id"]];for(let h=0;h<l.length;++h)if(l[h].expanded===n)return l[h].compacted}if(ue(n)||Rt(n)){const l=S.compactValue({activeCtx:e,activeProperty:t,value:n,options:r});return r.link&&Rt(n)&&(r.link.hasOwnProperty(n["@id"])||(r.link[n["@id"]]=[]),r.link[n["@id"]].push({expanded:n,compacted:l})),l}if(Ht(n)&&(B(e,t,"@container")||[]).includes("@list"))return S.compact({activeCtx:e,activeProperty:t,element:n["@list"],options:r,compactionMap:i});const s=t==="@reverse",o={},c=e;!ue(n)&&!Rt(n)&&(e=e.revertToPreviousContext());const u=B(c,t,"@context");At(u)||(e=await Lt({activeCtx:e,localCtx:u,propagate:!0,overrideProtected:!0,options:r})),r.link&&"@id"in n&&(r.link.hasOwnProperty(n["@id"])||(r.link[n["@id"]]=[]),r.link[n["@id"]].push({expanded:n,compacted:o}));let d=n["@type"]||[];d.length>1&&(d=Array.from(d).sort());const p=e;for(const l of d){const h=S.compactIri({activeCtx:p,iri:l,relativeTo:{vocab:!0}}),f=B(c,h,"@context");At(f)||(e=await Lt({activeCtx:e,localCtx:f,options:r,propagate:!1}))}const y=Object.keys(n).sort();for(const l of y){const h=n[l];if(l==="@id"){let f=Ze(h).map(m=>S.compactIri({activeCtx:e,iri:m,relativeTo:{vocab:!1},base:r.base}));f.length===1&&(f=f[0]);const g=S.compactIri({activeCtx:e,iri:"@id",relativeTo:{vocab:!0}});o[g]=f;continue}if(l==="@type"){let f=Ze(h).map(I=>S.compactIri({activeCtx:c,iri:I,relativeTo:{vocab:!0}}));f.length===1&&(f=f[0]);const g=S.compactIri({activeCtx:e,iri:"@type",relativeTo:{vocab:!0}}),v=(B(e,g,"@container")||[]).includes("@set")&&zs(e,1.1)||he(f)&&h.length===0;V(o,g,f,{propertyIsArray:v});continue}if(l==="@reverse"){const f=await S.compact({activeCtx:e,activeProperty:"@reverse",element:h,options:r,compactionMap:i});for(const g in f)if(e.mappings.has(g)&&e.mappings.get(g).reverse){const m=f[g],v=(B(e,g,"@container")||[]).includes("@set")||!r.compactArrays;V(o,g,m,{propertyIsArray:v}),delete f[g]}if(Object.keys(f).length>0){const g=S.compactIri({activeCtx:e,iri:l,relativeTo:{vocab:!0}});V(o,g,f)}continue}if(l==="@preserve"){const f=await S.compact({activeCtx:e,activeProperty:t,element:h,options:r,compactionMap:i});he(f)&&f.length===0||V(o,l,f);continue}if(l==="@index"){if((B(e,t,"@container")||[]).includes("@index"))continue;const g=S.compactIri({activeCtx:e,iri:l,relativeTo:{vocab:!0}});V(o,g,h);continue}if(l!=="@graph"&&l!=="@list"&&l!=="@included"&&Yn(l)){const f=S.compactIri({activeCtx:e,iri:l,relativeTo:{vocab:!0}});V(o,f,h);continue}if(!he(h))throw new Zt("JSON-LD expansion error; expanded value must be an array.","jsonld.SyntaxError");if(h.length===0){const f=S.compactIri({activeCtx:e,iri:l,value:h,relativeTo:{vocab:!0},reverse:s}),g=e.mappings.has(f)?e.mappings.get(f)["@nest"]:null;let m=o;g&&(Nn(e,g,r),be(o[g])||(o[g]={}),m=o[g]),V(m,f,h,{propertyIsArray:!0})}for(const f of h){const g=S.compactIri({activeCtx:e,iri:l,value:f,relativeTo:{vocab:!0},reverse:s}),m=e.mappings.has(g)?e.mappings.get(g)["@nest"]:null;let b=o;m&&(Nn(e,m,r),be(o[m])||(o[m]={}),b=o[m]);const v=B(e,g,"@container")||[],I=Wn(f),w=Ht(f);let x;w?x=f["@list"]:I&&(x=f["@graph"]);let N=await S.compact({activeCtx:e,activeProperty:g,element:w||I?x:f,options:r,compactionMap:i});if(w)if(he(N)||(N=[N]),!v.includes("@list"))N={[S.compactIri({activeCtx:e,iri:"@list",relativeTo:{vocab:!0}})]:N},"@index"in f&&(N[S.compactIri({activeCtx:e,iri:"@index",relativeTo:{vocab:!0}})]=f["@index"]);else{V(b,g,N,{valueIsArray:!0,allowDuplicate:!0});continue}if(I)if(v.includes("@graph")&&(v.includes("@id")||v.includes("@index")&&In(f))){let R;b.hasOwnProperty(g)?R=b[g]:b[g]=R={};const L=(v.includes("@id")?f["@id"]:f["@index"])||S.compactIri({activeCtx:e,iri:"@none",relativeTo:{vocab:!0}});V(R,L,N,{propertyIsArray:!r.compactArrays||v.includes("@set")})}else v.includes("@graph")&&In(f)?(he(N)&&N.length>1&&(N={"@included":N}),V(b,g,N,{propertyIsArray:!r.compactArrays||v.includes("@set")})):(he(N)&&N.length===1&&r.compactArrays&&(N=N[0]),N={[S.compactIri({activeCtx:e,iri:"@graph",relativeTo:{vocab:!0}})]:N},"@id"in f&&(N[S.compactIri({activeCtx:e,iri:"@id",relativeTo:{vocab:!0}})]=f["@id"]),"@index"in f&&(N[S.compactIri({activeCtx:e,iri:"@index",relativeTo:{vocab:!0}})]=f["@index"]),V(b,g,N,{propertyIsArray:!r.compactArrays||v.includes("@set")}));else if(v.includes("@language")||v.includes("@index")||v.includes("@id")||v.includes("@type")){let R;b.hasOwnProperty(g)?R=b[g]:b[g]=R={};let L;if(v.includes("@language"))ue(N)&&(N=N["@value"]),L=f["@language"];else if(v.includes("@index")){const P=B(e,g,"@index")||"@index",Oe=S.compactIri({activeCtx:e,iri:P,relativeTo:{vocab:!0}});if(P==="@index")L=f["@index"],delete N[Oe];else{let Xe;if([L,...Xe]=Ze(N[P]||[]),!Kn(L))L=null;else switch(Xe.length){case 0:delete N[P];break;case 1:N[P]=Xe[0];break;default:N[P]=Xe;break}}}else if(v.includes("@id")){const P=S.compactIri({activeCtx:e,iri:"@id",relativeTo:{vocab:!0}});L=N[P],delete N[P]}else if(v.includes("@type")){const P=S.compactIri({activeCtx:e,iri:"@type",relativeTo:{vocab:!0}});let Oe;switch([L,...Oe]=Ze(N[P]||[]),Oe.length){case 0:delete N[P];break;case 1:N[P]=Oe[0];break;default:N[P]=Oe;break}Object.keys(N).length===1&&"@id"in f&&(N=await S.compact({activeCtx:e,activeProperty:g,element:{"@id":f["@id"]},options:r,compactionMap:i}))}L||(L=S.compactIri({activeCtx:e,iri:"@none",relativeTo:{vocab:!0}})),V(R,L,N,{propertyIsArray:v.includes("@set")})}else{const R=!r.compactArrays||v.includes("@set")||v.includes("@list")||he(N)&&N.length===0||l==="@list"||l==="@graph";V(b,g,N,{propertyIsArray:R})}}}return o}return n};S.compactIri=({activeCtx:e,iri:t,value:n=null,relativeTo:r={vocab:!1},reverse:i=!1,base:a=null})=>{if(t===null)return t;e.isPropertyTermScoped&&e.previousContext&&(e=e.previousContext);const s=e.getInverse();if(Yn(t)&&t in s&&"@none"in s[t]&&"@type"in s[t]["@none"]&&"@none"in s[t]["@none"]["@type"])return s[t]["@none"]["@type"]["@none"];if(r.vocab&&t in s){const p=e["@language"]||"@none",y=[];be(n)&&"@index"in n&&!("@graph"in n)&&y.push("@index","@index@set"),be(n)&&"@preserve"in n&&(n=n["@preserve"][0]),Wn(n)?("@index"in n&&y.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in n&&y.push("@graph@id","@graph@id@set"),y.push("@graph","@graph@set","@set"),"@index"in n||y.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in n||y.push("@graph@id","@graph@id@set")):be(n)&&!ue(n)&&y.push("@id","@id@set","@type","@set@type");let l="@language",h="@null";if(i)l="@type",h="@reverse",y.push("@set");else if(Ht(n)){"@index"in n||y.push("@list");const g=n["@list"];if(g.length===0)l="@any",h="@none";else{let m=g.length===0?p:null,b=null;for(let v=0;v<g.length;++v){const I=g[v];let w="@none",x="@none";if(ue(I))if("@direction"in I){const N=(I["@language"]||"").toLowerCase(),R=I["@direction"];w=`${N}_${R}`}else"@language"in I?w=I["@language"].toLowerCase():"@type"in I?x=I["@type"]:w="@null";else x="@id";if(m===null?m=w:w!==m&&ue(I)&&(m="@none"),b===null?b=x:x!==b&&(b="@none"),m==="@none"&&b==="@none")break}m=m||"@none",b=b||"@none",b!=="@none"?(l="@type",h=b):h=m}}else{if(ue(n))if("@language"in n&&!("@index"in n)){y.push("@language","@language@set"),h=n["@language"];const g=n["@direction"];g&&(h=`${h}_${g}`)}else"@direction"in n&&!("@index"in n)?h=`_${n["@direction"]}`:"@type"in n&&(l="@type",h=n["@type"]);else l="@type",h="@id";y.push("@set")}y.push("@none"),be(n)&&!("@index"in n)&&y.push("@index","@index@set"),ue(n)&&Object.keys(n).length===1&&y.push("@language","@language@set");const f=Ks(e,t,n,y,l,h);if(f!==null)return f}if(r.vocab&&"@vocab"in e){const p=e["@vocab"];if(t.indexOf(p)===0&&t!==p){const y=t.substr(p.length);if(!e.mappings.has(y))return y}}let o=null;const c=[];let u=e.fastCurieMap;const d=t.length-1;for(let p=0;p<d&&t[p]in u;++p)u=u[t[p]],""in u&&c.push(u[""][0]);for(let p=c.length-1;p>=0;--p){const y=c[p],l=y.terms;for(const h of l){const f=h+":"+t.substr(y.iri.length);e.mappings.get(h)._prefix&&(!e.mappings.has(f)||n===null&&e.mappings.get(f)["@id"]===t)&&(o===null||Qs(f,o)<0)&&(o=f)}}if(o!==null)return o;for(const[p,y]of e.mappings)if(y&&y._prefix&&t.startsWith(p+":"))throw new Zt(`Absolute IRI "${t}" confused with prefix "${p}".`,"jsonld.SyntaxError",{code:"IRI confused with prefix",context:e});return r.vocab?t:"@base"in e?e["@base"]?xn(Hs(a,e["@base"]),t):t:xn(a,t)};S.compactValue=({activeCtx:e,activeProperty:t,value:n,options:r})=>{if(ue(n)){const o=B(e,t,"@type"),c=B(e,t,"@language"),u=B(e,t,"@direction"),d=B(e,t,"@container")||[],p="@index"in n&&!d.includes("@index");if(!p&&o!=="@none"&&(n["@type"]===o||"@language"in n&&n["@language"]===c&&"@direction"in n&&n["@direction"]===u||"@language"in n&&n["@language"]===c||"@direction"in n&&n["@direction"]===u))return n["@value"];const y=Object.keys(n).length,l=y===1||y===2&&"@index"in n&&!p,h="@language"in e,f=Kn(n["@value"]),g=e.mappings.has(t)&&e.mappings.get(t)["@language"]===null;if(l&&o!=="@none"&&(!h||!f||g))return n["@value"];const m={};return p&&(m[S.compactIri({activeCtx:e,iri:"@index",relativeTo:{vocab:!0}})]=n["@index"]),"@type"in n?m[S.compactIri({activeCtx:e,iri:"@type",relativeTo:{vocab:!0}})]=S.compactIri({activeCtx:e,iri:n["@type"],relativeTo:{vocab:!0}}):"@language"in n&&(m[S.compactIri({activeCtx:e,iri:"@language",relativeTo:{vocab:!0}})]=n["@language"]),"@direction"in n&&(m[S.compactIri({activeCtx:e,iri:"@direction",relativeTo:{vocab:!0}})]=n["@direction"]),m[S.compactIri({activeCtx:e,iri:"@value",relativeTo:{vocab:!0}})]=n["@value"],m}const i=Zn(e,t,{vocab:!0},r),a=B(e,t,"@type"),s=S.compactIri({activeCtx:e,iri:n["@id"],relativeTo:{vocab:a==="@vocab"},base:r.base});return a==="@id"||a==="@vocab"||i==="@graph"?s:{[S.compactIri({activeCtx:e,iri:"@id",relativeTo:{vocab:!0}})]:s}};function Ks(e,t,n,r,i,a){a===null&&(a="@null");const s=[];if((a==="@id"||a==="@reverse")&&be(n)&&"@id"in n){a==="@reverse"&&s.push("@reverse");const c=S.compactIri({activeCtx:e,iri:n["@id"],relativeTo:{vocab:!0}});e.mappings.has(c)&&e.mappings.get(c)&&e.mappings.get(c)["@id"]===n["@id"]?s.push.apply(s,["@vocab","@id"]):s.push.apply(s,["@id","@vocab"])}else{s.push(a);const c=s.find(u=>u.includes("_"));c&&s.push(c.replace(/^[^_]+_/,"_"))}s.push("@none");const o=e.inverse[t];for(const c of r){if(!(c in o))continue;const u=o[c][i];for(const d of s)if(d in u)return u[d]}return null}function Nn(e,t,n){if(Zn(e,t,{vocab:!0},n)!=="@nest")throw new Zt("JSON-LD compact error; nested property must have an @nest value resolving to @nest.","jsonld.SyntaxError",{code:"invalid @nest value"})}var Tt,_n;function Ws(){return _n||(_n=1,Tt=e=>{class t{toString(){return"[object JsonLdProcessor]"}}return Object.defineProperty(t,"prototype",{writable:!1,enumerable:!1}),Object.defineProperty(t.prototype,"constructor",{writable:!0,enumerable:!1,configurable:!0,value:t}),t.compact=function(n,r){return arguments.length<2?Promise.reject(new TypeError("Could not compact, too few arguments.")):e.compact(n,r)},t.expand=function(n){return arguments.length<1?Promise.reject(new TypeError("Could not expand, too few arguments.")):e.expand(n)},t.flatten=function(n){return arguments.length<1?Promise.reject(new TypeError("Could not flatten, too few arguments.")):e.flatten(n)},t}),Tt}/**
 * A JavaScript implementation of the JSON-LD API.
 *
 * @author Dave Longley
 *
 * @license BSD 3-Clause License
 * Copyright (c) 2011-2019 Digital Bazaar, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the Digital Bazaar, Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */const Sn=He,jn=Jr,ge=ne,oe=Zr,kt=ge.IdentifierIssuer,pe=ae,Zs=Fn,Ye=Cr,{expand:Ys}=ls,{flatten:Cs}=ps,{fromRDF:ei}=ws,{toRDF:ti}=$s,{frameMergedOrDefault:ni,cleanupNull:ri}=Ps,{isArray:Ee,isObject:xe,isString:re}=Z,{isSubjectReference:si}=fe,{expandIri:ii,getInitialContext:Ce,process:On,processingMode:Mt}=je,{compact:ai,compactIri:oi}=Xs,{createNodeMap:li,createMergedNodeMap:ci,mergeNodeMaps:ui}=ht,Cn=function(e){const t={},r=new Zs({max:100});e.compact=async function(a,s,o){if(arguments.length<2)throw new TypeError("Could not compact, too few arguments.");if(s===null)throw new pe("The compaction context must not be null.","jsonld.CompactError",{code:"invalid local context"});if(a===null)return null;o=i(o,{base:re(a)?a:"",compactArrays:!0,compactToRelative:!0,graph:!1,skipExpansion:!1,link:!1,issuer:new kt("_:b"),contextResolver:new oe({sharedCache:r})}),o.link&&(o.skipExpansion=!0),o.compactToRelative||delete o.base;let c;o.skipExpansion?c=a:c=await e.expand(a,o);const u=await e.processContext(Ce(o),s,o);let d=await ai({activeCtx:u,element:c,options:o,compactionMap:o.compactionMap});o.compactArrays&&!o.graph&&Ee(d)?d.length===1?d=d[0]:d.length===0&&(d={}):o.graph&&xe(d)&&(d=[d]),xe(s)&&"@context"in s&&(s=s["@context"]),s=ge.clone(s),Ee(s)||(s=[s]);const p=s;s=[];for(let l=0;l<p.length;++l)(!xe(p[l])||Object.keys(p[l]).length>0)&&s.push(p[l]);const y=s.length>0;if(s.length===1&&(s=s[0]),Ee(d)){const l=oi({activeCtx:u,iri:"@graph",relativeTo:{vocab:!0}}),h=d;d={},y&&(d["@context"]=s),d[l]=h}else if(xe(d)&&y){const l=d;d={"@context":s};for(const h in l)d[h]=l[h]}return d},e.expand=async function(a,s){if(arguments.length<1)throw new TypeError("Could not expand, too few arguments.");s=i(s,{keepFreeFloatingNodes:!1,contextResolver:new oe({sharedCache:r})}),s.expansionMap===!1&&(s.expansionMap=void 0);const o={},c=[];if("expandContext"in s){const y=ge.clone(s.expandContext);xe(y)&&"@context"in y?o.expandContext=y:o.expandContext={"@context":y},c.push(o.expandContext)}let u;if(!re(a))o.input=ge.clone(a);else{const y=await e.get(a,s);u=y.documentUrl,o.input=y.document,y.contextUrl&&(o.remoteContext={"@context":y.contextUrl},c.push(o.remoteContext))}"base"in s||(s.base=u||"");let d=Ce(s);for(const y of c)d=await On({activeCtx:d,localCtx:y,options:s});let p=await Ys({activeCtx:d,element:o.input,options:s,expansionMap:s.expansionMap});return xe(p)&&"@graph"in p&&Object.keys(p).length===1?p=p["@graph"]:p===null&&(p=[]),Ee(p)||(p=[p]),p},e.flatten=async function(a,s,o){if(arguments.length<1)return new TypeError("Could not flatten, too few arguments.");typeof s=="function"?s=null:s=s||null,o=i(o,{base:re(a)?a:"",contextResolver:new oe({sharedCache:r})});const c=await e.expand(a,o),u=Cs(c);return s===null?u:(o.graph=!0,o.skipExpansion=!0,await e.compact(u,s,o))},e.frame=async function(a,s,o){if(arguments.length<2)throw new TypeError("Could not frame, too few arguments.");if(o=i(o,{base:re(a)?a:"",embed:"@once",explicit:!1,requireAll:!1,omitDefault:!1,bnodesToClear:[],contextResolver:new oe({sharedCache:r})}),re(s)){const g=await e.get(s,o);if(s=g.document,g.contextUrl){let m=s["@context"];m?Ee(m)?m.push(g.contextUrl):m=[m,g.contextUrl]:m=g.contextUrl,s["@context"]=m}}const c=s?s["@context"]||{}:{},u=await e.processContext(Ce(o),c,o);o.hasOwnProperty("omitGraph")||(o.omitGraph=Mt(u,1.1)),o.hasOwnProperty("pruneBlankNodeIdentifiers")||(o.pruneBlankNodeIdentifiers=Mt(u,1.1));const d=await e.expand(a,o),p={...o};p.isFrame=!0,p.keepFreeFloatingNodes=!0;const y=await e.expand(s,p),l=Object.keys(s).map(g=>ii(u,g,{vocab:!0}));p.merged=!l.includes("@graph"),p.is11=Mt(u,1.1);const h=ni(d,y,p);p.graph=!o.omitGraph,p.skipExpansion=!0,p.link={},p.framing=!0;let f=await e.compact(h,c,p);return p.link={},f=ri(f,p),f},e.link=async function(a,s,o){const c={};return s&&(c["@context"]=s),c["@embed"]="@link",e.frame(a,c,o)},e.normalize=e.canonize=async function(a,s){if(arguments.length<1)throw new TypeError("Could not canonize, too few arguments.");if(s=i(s,{base:re(a)?a:"",algorithm:"URDNA2015",skipExpansion:!1,contextResolver:new oe({sharedCache:r})}),"inputFormat"in s){if(s.inputFormat!=="application/n-quads"&&s.inputFormat!=="application/nquads")throw new pe("Unknown canonicalization input format.","jsonld.CanonizeError");const u=Ye.parse(a);return Sn.canonize(u,s)}const o={...s};delete o.format,o.produceGeneralizedRdf=!1;const c=await e.toRDF(a,o);return Sn.canonize(c,s)},e.fromRDF=async function(a,s){if(arguments.length<1)throw new TypeError("Could not convert from RDF, too few arguments.");s=i(s,{format:re(a)?"application/n-quads":void 0});const{format:o}=s;let{rdfParser:c}=s;if(o){if(c=c||t[o],!c)throw new pe("Unknown input format.","jsonld.UnknownFormat",{format:o})}else c=()=>a;const u=await c(a);return ei(u,s)},e.toRDF=async function(a,s){if(arguments.length<1)throw new TypeError("Could not convert to RDF, too few arguments.");s=i(s,{base:re(a)?a:"",skipExpansion:!1,contextResolver:new oe({sharedCache:r})});let o;s.skipExpansion?o=a:o=await e.expand(a,s);const c=ti(o,s);if(s.format){if(s.format==="application/n-quads"||s.format==="application/nquads")return Ye.serialize(c);throw new pe("Unknown output format.","jsonld.UnknownFormat",{format:s.format})}return c},e.createNodeMap=async function(a,s){if(arguments.length<1)throw new TypeError("Could not create node map, too few arguments.");s=i(s,{base:re(a)?a:"",contextResolver:new oe({sharedCache:r})});const o=await e.expand(a,s);return ci(o,s)},e.merge=async function(a,s,o){if(arguments.length<1)throw new TypeError("Could not merge, too few arguments.");if(!Ee(a))throw new TypeError('Could not merge, "docs" must be an array.');typeof s=="function"?s=null:s=s||null,o=i(o,{contextResolver:new oe({sharedCache:r})});const c=await Promise.all(a.map(g=>{const m={...o};return e.expand(g,m)}));let u=!0;"mergeNodes"in o&&(u=o.mergeNodes);const d=o.issuer||new kt("_:b"),p={"@default":{}};for(let g=0;g<c.length;++g){const m=ge.relabelBlankNodes(c[g],{issuer:new kt("_:b"+g+"-")}),b=u||g===0?p:{"@default":{}};if(li(m,b,"@default",d),b!==p)for(const v in b){const I=b[v];if(!(v in p)){p[v]=I;continue}const w=p[v];for(const x in I)x in w||(w[x]=I[x])}}const y=ui(p),l=[],h=Object.keys(y).sort();for(let g=0;g<h.length;++g){const m=y[h[g]];si(m)||l.push(m)}return s===null?l:(o.graph=!0,o.skipExpansion=!0,await e.compact(l,s,o))},Object.defineProperty(e,"documentLoader",{get:()=>e._documentLoader,set:a=>e._documentLoader=a}),e.documentLoader=async a=>{throw new pe("Could not retrieve a JSON-LD document from the URL. URL dereferencing not implemented.","jsonld.LoadDocumentError",{code:"loading document failed",url:a})},e.get=async function(a,s){let o;typeof s.documentLoader=="function"?o=s.documentLoader:o=e.documentLoader;const c=await o(a);try{if(!c.document)throw new pe("No remote document found at the given URL.","jsonld.NullRemoteDocument");re(c.document)&&(c.document=JSON.parse(c.document))}catch(u){throw new pe("Could not retrieve a JSON-LD document from the URL.","jsonld.LoadDocumentError",{code:"loading document failed",cause:u,remoteDoc:c})}return c},e.processContext=async function(a,s,o){return o=i(o,{base:"",contextResolver:new oe({sharedCache:r})}),s===null?Ce(o):(s=ge.clone(s),xe(s)&&"@context"in s||(s={"@context":s}),On({activeCtx:a,localCtx:s,options:o}))},e.getContextValue=je.getContextValue,e.documentLoaders={},e.useDocumentLoader=function(a){if(!(a in e.documentLoaders))throw new pe('Unknown document loader type: "'+a+'"',"jsonld.UnknownDocumentLoader",{type:a});e.documentLoader=e.documentLoaders[a].apply(e,Array.prototype.slice.call(arguments,1))},e.registerRDFParser=function(a,s){t[a]=s},e.unregisterRDFParser=function(a){delete t[a]},e.registerRDFParser("application/n-quads",Ye.parse),e.registerRDFParser("application/nquads",Ye.parse),e.url=ve,e.util=ge,Object.assign(e,ge),e.promises=e,e.RequestQueue=Mn(),e.JsonLdProcessor=Ws()(e),jn.setupGlobals(e),jn.setupDocumentLoaders(e);function i(a,{documentLoader:s=e.documentLoader,...o}){return Object.assign({},{documentLoader:s},o,a)}return e},Yt=function(){return Cn(function(){return Yt()})};Cn(Yt);var Dn=Yt;const xi=tr({__proto__:null,default:Dn},[Dn]);export{xi as j};
